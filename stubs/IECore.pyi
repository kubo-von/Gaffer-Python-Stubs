
def BSpline (*args):
      '''

'''      
    ...

def BasicPreset (*args):
      '''

'''      
    ...

class BasicPreset:
    def _addClassToVector (self, parameter, parameterName, className, classVersion):
      '''None'''
    ...
    def _applicableTo (self, parameterised, parameter, data):
      '''None'''
    ...
    def _applyClassParameter (self, parameterised, parameter, data, parameterList=[], invertList=False):
      '''None'''
    ...
    def _applyClassVector (self, parameterised, parameter, data, parameterList=[], invertList=False):
      '''None'''
    ...
    def _applyHierarchy (self, parameterised, parameter, data, parameterList=[], invertList=False):
      '''None'''
    ...
    def _applyParameter (self, parameterised, parameter, data):
      '''None'''
    ...
    def _ensureData (self):
      '''None'''
    ...
    def _ensureHeader (self):
      '''None'''
    ...
    def _grabClassParameter (parameter, data, parameterList):
      '''None'''
    ...
    def _grabClassVectorParameter (parameter, data, parameterList):
      '''None'''
    ...
    def _grabHierarchy (data, parameter, parameterList=()):
      '''None'''
    ...
    def _grabParameter (parameter, data):
      '''None'''
    ...
    def _pruneHierarchy (data):
      '''None'''
    ...
    def _writePy (fileName, cob, className):
      '''None'''
    ...
    def applicableTo (self, parameterised, rootParameter):
      '''None'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def metadata (self):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def save (self, path, name, title='', description='', categories=(), version=1, classLoadable=True):
      '''None'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def Bezier (*args):
      '''

'''      
    ...

def BinaryFrameList (*args):
      '''
__init__(_object*)
__init__(_object*, boost::intrusive_ptr<IECore::FrameList>)

'''      
    ...

class BinaryFrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def frameList (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (BinaryFrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::BinaryFrameList {lvalue},IECore::TypeId)

isInstanceOf( (BinaryFrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::BinaryFrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (BinaryFrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::BinaryFrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (BinaryFrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::BinaryFrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def BlindDataHolder (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::CompoundData>)
__init__(_object*)

'''      
    ...

class BlindDataHolder:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def blindData (self, *args, **kwargs):
      '''
blindData( (BlindDataHolder)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundData> blindData(IECore::BlindDataHolder {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (BlindDataHolder)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::BlindDataHolder {lvalue},IECore::TypeId)

isInstanceOf( (BlindDataHolder)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::BlindDataHolder {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (BlindDataHolder)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::BlindDataHolder {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (BlindDataHolder)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::BlindDataHolder {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def BoolData (*args):
      '''
__init__(boost::python::api::object, bool)
__init__(_object*)

'''      
    ...

class BoolData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (BoolData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<bool> {lvalue},IECore::TypeId)

isInstanceOf( (BoolData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<bool> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (BoolData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<bool> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (BoolData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<bool> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def BoolParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class BoolParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (BoolParameter)arg1) -> bool :

    C++ signature :
        bool getTypedValue(IECore::TypedParameter<bool> {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (BoolParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<bool> {lvalue},IECore::TypeId)

isInstanceOf( (BoolParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<bool> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (BoolParameter)arg1, (bool)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<bool> {lvalue},bool)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (BoolParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<bool> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (BoolParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<bool> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (BoolParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<bool>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def BoolVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class BoolVectorData:
    def append (self, *args, **kwargs):
      '''
append( (BoolVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (BoolVectorData)arg1, (bool)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},bool)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (BoolVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (BoolVectorData)arg1, (bool)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},bool,long,long)

index( (BoolVectorData)arg1, (bool)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},bool)

index( (BoolVectorData)arg1, (bool)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},bool,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (BoolVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (BoolVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},IECore::TypeId)

isInstanceOf( (BoolVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (BoolVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},unsigned long)

resize( (BoolVectorData)arg1, (int)arg2, (bool)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue},unsigned long,bool)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (BoolVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (BoolVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (BoolVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<bool, std::allocator<bool> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def BoolVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class BoolVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (BoolVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<bool, std::allocator<bool> > getTypedValue(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (BoolVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > > {lvalue},IECore::TypeId)

isInstanceOf( (BoolVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (BoolVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > > {lvalue},std::vector<bool, std::allocator<bool> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (BoolVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (BoolVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (BoolVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<bool, std::allocator<bool> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box2dData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Box<Imath_3_1::Vec2<double> >)
__init__(_object*)

'''      
    ...

class Box2dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Box2dParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box2dParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box2dParameter)arg1) -> Box2d :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec2<double> > getTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2dParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2dParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box2dParameter)arg1, (Box2d)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2dParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2dParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box2dParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<double> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box2dTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > >)

'''      
    ...

class Box2dTree:
    def intersectingBounds (self, *args, **kwargs):
      '''
intersectingBounds( (Box2dTree)arg1, (Box2d)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec2<double> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >)

intersectingBounds( (Box2dTree)arg1, (V2d)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec2<double> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > > > {lvalue},Imath_3_1::Vec2<double>)'''
    ...

def Box2dVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Box2dVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Box2dVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Box2dVectorData)arg1, (Box2d)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Box2dVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Box2dVectorData)arg1, (Box2d)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >,long,long)

index( (Box2dVectorData)arg1, (Box2d)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >)

index( (Box2dVectorData)arg1, (Box2d)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Box2dVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2dVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2dVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Box2dVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},unsigned long)

resize( (Box2dVectorData)arg1, (int)arg2, (Box2d)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue},unsigned long,Imath_3_1::Box<Imath_3_1::Vec2<double> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Box2dVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2dVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2dVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Box2fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Box<Imath_3_1::Vec2<float> >)
__init__(_object*)

'''      
    ...

class Box2fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Box2fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box2fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box2fParameter)arg1) -> Box2f :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec2<float> > getTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box2fParameter)arg1, (Box2f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box2fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<float> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box2fTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > >)

'''      
    ...

class Box2fTree:
    def intersectingBounds (self, *args, **kwargs):
      '''
intersectingBounds( (Box2fTree)arg1, (Box2f)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec2<float> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >)

intersectingBounds( (Box2fTree)arg1, (V2f)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec2<float> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > > > {lvalue},Imath_3_1::Vec2<float>)'''
    ...

def Box2fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Box2fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Box2fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Box2fVectorData)arg1, (Box2f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Box2fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Box2fVectorData)arg1, (Box2f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >,long,long)

index( (Box2fVectorData)arg1, (Box2f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >)

index( (Box2fVectorData)arg1, (Box2f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Box2fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Box2fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},unsigned long)

resize( (Box2fVectorData)arg1, (int)arg2, (Box2f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue},unsigned long,Imath_3_1::Box<Imath_3_1::Vec2<float> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Box2fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Box2iData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Box<Imath_3_1::Vec2<int> >)
__init__(_object*)

'''      
    ...

class Box2iData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2iData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2iData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2iData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2iData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Box2iParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box2iParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box2iParameter)arg1) -> Box2i :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec2<int> > getTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2iParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2iParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box2iParameter)arg1, (Box2i)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<int> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2iParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2iParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box2iParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec2<int> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box2iVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Box2iVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Box2iVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Box2iVectorData)arg1, (Box2i)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<int> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Box2iVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Box2iVectorData)arg1, (Box2i)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<int> >,long,long)

index( (Box2iVectorData)arg1, (Box2i)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<int> >)

index( (Box2iVectorData)arg1, (Box2i)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<int> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Box2iVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box2iVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box2iVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Box2iVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},unsigned long)

resize( (Box2iVectorData)arg1, (int)arg2, (Box2i)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue},unsigned long,Imath_3_1::Box<Imath_3_1::Vec2<int> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Box2iVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box2iVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box2iVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Box3dData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Box<Imath_3_1::Vec3<double> >)
__init__(_object*)

'''      
    ...

class Box3dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Box3dParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box3dParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box3dParameter)arg1) -> Box3d :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec3<double> > getTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3dParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3dParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box3dParameter)arg1, (Box3d)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3dParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3dParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box3dParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<double> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box3dTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > >)

'''      
    ...

class Box3dTree:
    def intersectingBounds (self, *args, **kwargs):
      '''
intersectingBounds( (Box3dTree)arg1, (Box3d)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec3<double> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >)

intersectingBounds( (Box3dTree)arg1, (V3d)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec3<double> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > > > {lvalue},Imath_3_1::Vec3<double>)'''
    ...

def Box3dVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Box3dVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Box3dVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Box3dVectorData)arg1, (Box3d)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Box3dVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Box3dVectorData)arg1, (Box3d)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >,long,long)

index( (Box3dVectorData)arg1, (Box3d)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >)

index( (Box3dVectorData)arg1, (Box3d)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Box3dVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3dVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3dVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Box3dVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},unsigned long)

resize( (Box3dVectorData)arg1, (int)arg2, (Box3d)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},unsigned long,Imath_3_1::Box<Imath_3_1::Vec3<double> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Box3dVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3dVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3dVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Box3dVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box3dVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box3dVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3dVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3dVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box3dVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue},std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3dVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3dVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box3dVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box3fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Box<Imath_3_1::Vec3<float> >)
__init__(_object*)

'''      
    ...

class Box3fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Box3fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box3fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box3fParameter)arg1) -> Box3f :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec3<float> > getTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box3fParameter)arg1, (Box3f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box3fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<float> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box3fTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > >)

'''      
    ...

class Box3fTree:
    def intersectingBounds (self, *args, **kwargs):
      '''
intersectingBounds( (Box3fTree)arg1, (Box3f)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec3<float> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >)

intersectingBounds( (Box3fTree)arg1, (V3f)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > intersectingBounds(IECorePython::BoundedKDTreeWrapper<IECore::BoundedKDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Box<Imath_3_1::Vec3<float> > const*, std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > > > {lvalue},Imath_3_1::Vec3<float>)'''
    ...

def Box3fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Box3fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Box3fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Box3fVectorData)arg1, (Box3f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Box3fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Box3fVectorData)arg1, (Box3f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >,long,long)

index( (Box3fVectorData)arg1, (Box3f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >)

index( (Box3fVectorData)arg1, (Box3f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Box3fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Box3fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},unsigned long)

resize( (Box3fVectorData)arg1, (int)arg2, (Box3f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},unsigned long,Imath_3_1::Box<Imath_3_1::Vec3<float> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Box3fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Box3fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box3fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box3fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box3fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue},std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box3fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box3iData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Box<Imath_3_1::Vec3<int> >)
__init__(_object*)

'''      
    ...

class Box3iData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3iData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3iData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3iData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3iData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Box3iParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Box3iParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Box3iParameter)arg1) -> Box3i :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec3<int> > getTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3iParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3iParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Box3iParameter)arg1, (Box3i)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<int> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3iParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3iParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Box3iParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Box<Imath_3_1::Vec3<int> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Box3iVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Box3iVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Box3iVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Box3iVectorData)arg1, (Box3i)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<int> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Box3iVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Box3iVectorData)arg1, (Box3i)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<int> >,long,long)

index( (Box3iVectorData)arg1, (Box3i)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<int> >)

index( (Box3iVectorData)arg1, (Box3i)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<int> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Box3iVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Box3iVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (Box3iVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Box3iVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},unsigned long)

resize( (Box3iVectorData)arg1, (int)arg2, (Box3i)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue},unsigned long,Imath_3_1::Box<Imath_3_1::Vec3<int> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Box3iVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Box3iVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Box3iVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def BoxAlgo (*args):
      '''

'''      
    ...

def CachedReader (*args):
      '''
__init__(_object*, IECore::SearchPath, boost::intrusive_ptr<IECore::ModifyOp const>)
__init__(_object*, IECore::SearchPath, boost::intrusive_ptr<IECore::ModifyOp const>, boost::intrusive_ptr<IECore::ObjectPool>)
__init__(_object*, IECore::SearchPath)
__init__(_object*, IECore::SearchPath, boost::intrusive_ptr<IECore::ObjectPool>)

'''      
    ...

class CachedReader:
    def cached (self, *args, **kwargs):
      '''
cached( (CachedReader)arg1, (object)arg2) -> bool :

    C++ signature :
        bool cached(IECore::CachedReader {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def clear (self, *args, **kwargs):
      '''
clear( (CachedReader)arg1 [, (object)arg2]) -> None :

    C++ signature :
        void clear(IECore::CachedReader {lvalue} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >])'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultCachedReader (self, *args, **kwargs):
      '''
defaultCachedReader() -> object :

    C++ signature :
        IECore::CachedReader* defaultCachedReader()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (CachedReader)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void insert(IECore::CachedReader {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::intrusive_ptr<IECore::Object const>)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def objectPool (self, *args, **kwargs):
      '''
objectPool( (CachedReader)arg1) -> object :

    C++ signature :
        IECore::ObjectPool* objectPool(IECore::CachedReader {lvalue})'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (CachedReader)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> read(IECore::CachedReader {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def searchPath (self, *args, **kwargs):
      '''None'''
    ...

def CamelCase (*args):
      '''
__init__(_object*)

'''      
    ...

class CamelCase:
    def Caps (self, *args, **kwargs):
      '''None'''
    ...
    def fromSpaced (self, *args, **kwargs):
      '''
fromSpaced( (object)spaced [, (Caps)caps=IECore._IECore.Caps.All]) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > fromSpaced(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,IECore::CamelCase::Caps=IECore._IECore.Caps.All])'''
    ...
    def join (self, *args, **kwargs):
      '''
join( (object)words [, (Caps)caps=IECore._IECore.Caps.All [, (object)separator='']]) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > join(boost::python::api::object [,IECore::CamelCase::Caps=IECore._IECore.Caps.All [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >='']])'''
    ...
    def split (self, *args, **kwargs):
      '''
split( (object)arg1) -> list :

    C++ signature :
        boost::python::list split(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def toSpaced (self, *args, **kwargs):
      '''
toSpaced( (object)camelCase [, (Caps)caps=IECore._IECore.Caps.All]) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > toSpaced(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,IECore::CamelCase::Caps=IECore._IECore.Caps.All])'''
    ...

def Cancelled (*args):
      '''

'''      
    ...

class Cancelled:
    def args (self, *args, **kwargs):
      '''None'''
    ...
    def with_traceback (self, *args, **kwargs):
      '''Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.'''
    ...

def Canceller (*args):
      '''
__init__(_object*)

'''      
    ...

class Canceller:
    def cancel (self, *args, **kwargs):
      '''
cancel( (Canceller)arg1) -> None :

    C++ signature :
        void cancel(IECore::Canceller {lvalue})'''
    ...
    def cancelled (self, *args, **kwargs):
      '''
cancelled( (Canceller)arg1) -> bool :

    C++ signature :
        bool cancelled(IECore::Canceller {lvalue})'''
    ...
    def check (self, *args, **kwargs):
      '''
check( (Canceller)arg1) -> None :

    C++ signature :
        void check(IECore::Canceller const*)'''
    ...
    def elapsedTime (self, *args, **kwargs):
      '''
elapsedTime( (Canceller)arg1) -> float :

    C++ signature :
        double elapsedTime(IECore::Canceller)'''
    ...

def CapturingMessageHandler (*args):
      '''

'''      
    ...

class CapturingMessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, level, context, message):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def CatmullRom (*args):
      '''

'''      
    ...

def CharData (*args):
      '''
__init__(boost::python::api::object, char)
__init__(_object*)

'''      
    ...

class CharData:

def CharVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class CharVectorData:
    def append (self, *args, **kwargs):
      '''
append( (CharVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (CharVectorData)arg1, (str)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},char)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (CharVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (CharVectorData)arg1, (str)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},char,long,long)

index( (CharVectorData)arg1, (str)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},char)

index( (CharVectorData)arg1, (str)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},char,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (CharVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CharVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},IECore::TypeId)

isInstanceOf( (CharVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (CharVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},unsigned long)

resize( (CharVectorData)arg1, (int)arg2, (str)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue},unsigned long,char)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (CharVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (CharVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CharVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CharVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<char, std::allocator<char> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def ClassLoader (*args):
      '''

'''      
    ...

class ClassLoader:
    def _ClassLoader__defaultLoaderMutex (self, *args, **kwargs):
      '''A lock object is a synchronization primitive.  To create a lock,
call threading.Lock().  Methods are:

acquire() -- lock the lock, possibly blocking until it can be obtained
release() -- unlock of the lock
locked() -- test whether the lock is currently locked

A lock is not owned by the thread that locked it; another thread may
unlock it.  A thread attempting to lock a lock that it has already locked
will block until another thread unlocks it.  Deadlocks may ensue.'''
    ...
    def _ClassLoader__defaultLoaders (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def _ClassLoader__findAllClasses (self):
      '''None'''
    ...
    def _ClassLoader__findClass (self, name):
      '''None'''
    ...
    def _ClassLoader__updateClassFromSearchPath (self, searchPath, name):
      '''None'''
    ...
    def _ClassLoader__validateVersion (version):
      '''None'''
    ...
    def classNames (self, matchString='*'):
      '''None'''
    ...
    def defaultLoader (envVar):
      '''None'''
    ...
    def defaultOpLoader ():
      '''None'''
    ...
    def getDefaultVersion (self, name):
      '''None'''
    ...
    def load (self, name, version=None):
      '''None'''
    ...
    def refresh (self):
      '''None'''
    ...
    def searchPath (self):
      '''None'''
    ...
    def setDefaultVersion (self, name, version):
      '''None'''
    ...
    def versions (self, name):
      '''None'''
    ...

def ClassLsOp (*args):
      '''

'''      
    ...

class ClassLsOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def ClassParameter (*args):
      '''

'''      
    ...

class ClassParameter:
    def _parse (args, parameter):
      '''None'''
    ...
    def _serialise (parameter, value):
      '''None'''
    ...
    def addParameter (self, *args, **kwargs):
      '''
addParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void addParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)'''
    ...
    def addParameters (self, *args, **kwargs):
      '''
addParameters( (CompoundParameter)arg1, (list)arg2) -> None :

    C++ signature :
        void addParameters(IECore::CompoundParameter {lvalue},boost::python::list)'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def clearParameters (self, *args, **kwargs):
      '''
clearParameters( (CompoundParameter)arg1) -> None :

    C++ signature :
        void clearParameters(IECore::CompoundParameter {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getClass (self, withClassLoaderArgs=False):
      '''None'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundParameter)arg1, (object)arg2) -> bool :

    C++ signature :
        bool has_key(IECore::CompoundParameter,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def insertParameter (self, *args, **kwargs):
      '''
insertParameter( (CompoundParameter)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void insertParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>,boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list items(IECore::CompoundParameter)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list keys(IECore::CompoundParameter)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameter (self, *args, **kwargs):
      '''
parameter( (CompoundParameter)arg1, (str)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> parameter(IECore::CompoundParameter {lvalue},char const*)'''
    ...
    def parameterPath (self, *args, **kwargs):
      '''
parameterPath( (CompoundParameter)arg1, (object)arg2) -> list :

    C++ signature :
        boost::python::list parameterPath(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def removeParameter (self, *args, **kwargs):
      '''
removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)

removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setClass (self, className, classVersion, searchPathEnvVar=None):
      '''None'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for CompoundParameter objects. Uses introspection on the given value to define
	how the value will be assigned to the CompoundParameter object.
	'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (CompoundParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::CompoundParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list values(IECore::CompoundParameter)'''
    ...

def ClassVectorParameter (*args):
      '''

'''      
    ...

class ClassVectorParameter:
    def _parse (args, parameter):
      '''None'''
    ...
    def _serialise (parameter, value):
      '''None'''
    ...
    def addParameter (self, *args, **kwargs):
      '''
addParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void addParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)'''
    ...
    def addParameters (self, *args, **kwargs):
      '''
addParameters( (CompoundParameter)arg1, (list)arg2) -> None :

    C++ signature :
        void addParameters(IECore::CompoundParameter {lvalue},boost::python::list)'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def clearParameters (self, *args, **kwargs):
      '''
clearParameters( (CompoundParameter)arg1) -> None :

    C++ signature :
        void clearParameters(IECore::CompoundParameter {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getClass (self, parameterOrParameterName, withClassLoaderArgs=False):
      '''None'''
    ...
    def getClasses (self, withClassLoaderArgs=False):
      '''None'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundParameter)arg1, (object)arg2) -> bool :

    C++ signature :
        bool has_key(IECore::CompoundParameter,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def insertParameter (self, *args, **kwargs):
      '''
insertParameter( (CompoundParameter)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void insertParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>,boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list items(IECore::CompoundParameter)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list keys(IECore::CompoundParameter)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def newParameterName (self, prefix='p'):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameter (self, *args, **kwargs):
      '''
parameter( (CompoundParameter)arg1, (str)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> parameter(IECore::CompoundParameter {lvalue},char const*)'''
    ...
    def parameterPath (self, *args, **kwargs):
      '''
parameterPath( (CompoundParameter)arg1, (object)arg2) -> list :

    C++ signature :
        boost::python::list parameterPath(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def removeClass (self, parameterName):
      '''None'''
    ...
    def removeParameter (self, *args, **kwargs):
      '''
removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)

removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def searchPathEnvVar (self):
      '''None'''
    ...
    def setClass (self, parameterOrParameterName, className, classVersion):
      '''None'''
    ...
    def setClasses (self, classes):
      '''None'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for CompoundParameter objects. Uses introspection on the given value to define
	how the value will be assigned to the CompoundParameter object.
	'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (CompoundParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::CompoundParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list values(IECore::CompoundParameter)'''
    ...

def Color3fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Color3<float>)
__init__(_object*)

'''      
    ...

class Color3fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color3fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Color3<float> > {lvalue},IECore::TypeId)

isInstanceOf( (Color3fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Color3<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color3fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Color3<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color3fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Color3<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Color3fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Color3fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Color3fParameter)arg1) -> Color3f :

    C++ signature :
        Imath_3_1::Color3<float> getTypedValue(IECore::TypedParameter<Imath_3_1::Color3<float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color3fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Color3<float> > {lvalue},IECore::TypeId)

isInstanceOf( (Color3fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Color3<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Color3fParameter)arg1, (Color3f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Color3<float> > {lvalue},Imath_3_1::Color3<float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color3fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Color3<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color3fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Color3<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Color3fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Color3<float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Color3fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Color3fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Color3fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Color3fVectorData)arg1, (Color3f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},Imath_3_1::Color3<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Color3fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Color3fVectorData)arg1, (Color3f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},Imath_3_1::Color3<float>,long,long)

index( (Color3fVectorData)arg1, (Color3f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},Imath_3_1::Color3<float>)

index( (Color3fVectorData)arg1, (Color3f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},Imath_3_1::Color3<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Color3fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color3fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (Color3fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Color3fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},unsigned long)

resize( (Color3fVectorData)arg1, (int)arg2, (Color3f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},unsigned long,Imath_3_1::Color3<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Color3fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Color3fVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color3fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color3fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Color3fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Color3fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Color3fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color3fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (Color3fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Color3fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue},std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color3fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color3fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Color3fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Color4fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Color4<float>)
__init__(_object*)

'''      
    ...

class Color4fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color4fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Color4<float> > {lvalue},IECore::TypeId)

isInstanceOf( (Color4fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Color4<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color4fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Color4<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color4fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Color4<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Color4fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Color4fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Color4fParameter)arg1) -> Color4f :

    C++ signature :
        Imath_3_1::Color4<float> getTypedValue(IECore::TypedParameter<Imath_3_1::Color4<float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color4fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Color4<float> > {lvalue},IECore::TypeId)

isInstanceOf( (Color4fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Color4<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Color4fParameter)arg1, (Color4f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Color4<float> > {lvalue},Imath_3_1::Color4<float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color4fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Color4<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color4fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Color4<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Color4fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Color4<float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Color4fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Color4fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (Color4fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Color4fVectorData)arg1, (Color4f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},Imath_3_1::Color4<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Color4fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Color4fVectorData)arg1, (Color4f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},Imath_3_1::Color4<float>,long,long)

index( (Color4fVectorData)arg1, (Color4f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},Imath_3_1::Color4<float>)

index( (Color4fVectorData)arg1, (Color4f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},Imath_3_1::Color4<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Color4fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color4fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (Color4fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Color4fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},unsigned long)

resize( (Color4fVectorData)arg1, (int)arg2, (Color4f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},unsigned long,Imath_3_1::Color4<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Color4fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Color4fVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color4fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color4fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Color4fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Color4fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (Color4fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Color4fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (Color4fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (Color4fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue},std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Color4fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Color4fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Color4fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def CompoundData (*args):
      '''
__init__(boost::python::api::object, boost::python::dict)
__init__(_object*)

'''      
    ...

class CompoundData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def clear (self, *args, **kwargs):
      '''
clear( (CompoundData)arg1) -> None :
    m.clear()
    Removes all items from m.

    C++ signature :
        void clear(IECore::CompoundData {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def get (self, *args, **kwargs):
      '''
get( (CompoundData)self, (object)key [, (object)defaultValue=None]) -> object :
    m.get(k [, v])
    Returns m[k] if found; otherwise, returns v.

    C++ signature :
        boost::intrusive_ptr<IECore::Data> get(IECore::CompoundData {lvalue},_object* [,_object*=None])'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundData)arg1, (object)arg2) -> bool :
    m.has_key(k)
    Returns True if m has key k; otherwise, returns False.

    C++ signature :
        bool has_key(IECore::CompoundData {lvalue},_object*)'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CompoundData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundData {lvalue},IECore::TypeId)

isInstanceOf( (CompoundData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundData {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundData)arg1) -> list :
    m.items()
    Returns a list of (key, value) pairs.

    C++ signature :
        boost::python::list items(IECore::CompoundData {lvalue})'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundData)arg1) -> list :
    m.keys()
    Returns a list of key values.

    C++ signature :
        boost::python::list keys(IECore::CompoundData {lvalue})'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def pop (self, *args, **kwargs):
      '''
pop( (CompoundData)arg1, (object)arg2, (object)arg3) -> object :
    m.pop(k [,default])
    Returns m[k] if found and removes it from m; otherwise, returns default if supplied or raises KeyError if not.

    C++ signature :
        boost::intrusive_ptr<IECore::Data> pop(IECore::CompoundData {lvalue},_object*,_object*)

pop( (CompoundData)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Data> pop(IECore::CompoundData {lvalue},_object*)'''
    ...
    def popitem (self, *args, **kwargs):
      '''
popitem( (CompoundData)arg1) -> tuple :
    m.popitem()
    Remvoes a random (key,value) pair from m and returns it as a tuple.

    C++ signature :
        boost::python::tuple popitem(IECore::CompoundData {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setdefault (self, *args, **kwargs):
      '''
setdefault( (CompoundData)arg1, (object)arg2, (object)arg3) -> object :
    m.setdefault(k [, v])
    Returns m[k] if found; otherwise, returns v and sets m[k] = v.

    C++ signature :
        boost::intrusive_ptr<IECore::Data> setdefault(IECore::CompoundData {lvalue},_object*,_object*)

setdefault( (CompoundData)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Data> setdefault(IECore::CompoundData {lvalue},_object*)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (CompoundData)arg1) -> int :
    m.size()
    Returns the number of elements on m. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::CompoundData {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CompoundData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::CompoundData {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CompoundData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::CompoundData {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def update (self, *args, **kwargs):
      '''
update( (CompoundData)arg1, (object)arg2) -> None :
    m.update(b)
    Adds all objects from b to m. b can be a CompoundData or a python dict.

    C++ signature :
        void update(IECore::CompoundData {lvalue},boost::intrusive_ptr<IECore::CompoundData const>)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundData)arg1) -> list :
    m.values()
    Returns a list of all values in m.

    C++ signature :
        boost::python::list values(IECore::CompoundData {lvalue})'''
    ...

def CompoundDataBase (*args):
      '''

'''      
    ...

class CompoundDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CompoundDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::map<IECore::InternedString, boost::intrusive_ptr<IECore::Data>, std::less<IECore::InternedString>, std::allocator<std::pair<IECore::InternedString const, boost::intrusive_ptr<IECore::Data> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (CompoundDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::map<IECore::InternedString, boost::intrusive_ptr<IECore::Data>, std::less<IECore::InternedString>, std::allocator<std::pair<IECore::InternedString const, boost::intrusive_ptr<IECore::Data> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CompoundDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::map<IECore::InternedString, boost::intrusive_ptr<IECore::Data>, std::less<IECore::InternedString>, std::allocator<std::pair<IECore::InternedString const, boost::intrusive_ptr<IECore::Data> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CompoundDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::map<IECore::InternedString, boost::intrusive_ptr<IECore::Data>, std::less<IECore::InternedString>, std::allocator<std::pair<IECore::InternedString const, boost::intrusive_ptr<IECore::Data> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def CompoundFrameList (*args):
      '''
__init__(boost::python::api::object, boost::python::list)
__init__(_object*)

'''      
    ...

class CompoundFrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def frameLists (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CompoundFrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundFrameList {lvalue},IECore::TypeId)

isInstanceOf( (CompoundFrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundFrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CompoundFrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::CompoundFrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CompoundFrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::CompoundFrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def CompoundMessageHandler (*args):
      '''
__init__(_object*)

'''      
    ...

class CompoundMessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def addHandler (self, *args, **kwargs):
      '''
addHandler( (CompoundMessageHandler)arg1, (object)arg2) -> None :

    C++ signature :
        void addHandler(IECore::CompoundMessageHandler {lvalue},boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def removeHandler (self, *args, **kwargs):
      '''
removeHandler( (CompoundMessageHandler)arg1, (object)arg2) -> None :

    C++ signature :
        void removeHandler(IECore::CompoundMessageHandler {lvalue},boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def CompoundObject (*args):
      '''
__init__(boost::python::api::object, boost::intrusive_ptr<IECore::CompoundObject const>)
__init__(_object*)

'''      
    ...

class CompoundObject:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def defaultInstance (self, *args, **kwargs):
      '''
defaultInstance() -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> defaultInstance()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def get (self, *args, **kwargs):
      '''
get( (CompoundObject)self, (InternedString)key [, (object)defaultValue=None]) -> object :
    m.get(k [, v])
    Returns m[k] if found; otherwise, returns v.

    C++ signature :
        boost::intrusive_ptr<IECore::Object> get(IECore::CompoundObject,IECore::InternedString [,boost::intrusive_ptr<IECore::Object>=None])'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundObject)arg1, (InternedString)arg2) -> bool :

    C++ signature :
        bool has_key(IECore::CompoundObject,IECore::InternedString)'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CompoundObject)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundObject {lvalue},IECore::TypeId)

isInstanceOf( (CompoundObject)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundObject {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundObject)arg1) -> list :

    C++ signature :
        boost::python::list items(IECore::CompoundObject)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundObject)arg1) -> list :

    C++ signature :
        boost::python::list keys(IECore::CompoundObject)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CompoundObject)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::CompoundObject {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CompoundObject)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::CompoundObject {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def update (self, *args, **kwargs):
      '''
update( (CompoundObject)arg1, (object)arg2) -> None :

    C++ signature :
        void update(IECore::CompoundObject {lvalue},boost::intrusive_ptr<IECore::CompoundObject const>)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundObject)arg1) -> list :

    C++ signature :
        boost::python::list values(IECore::CompoundObject)'''
    ...

def CompoundObjectParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::CompoundObject> defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::CompoundObject> defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::CompoundObject> defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::CompoundObject> defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class CompoundObjectParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CompoundObjectParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedObjectParameter<IECore::CompoundObject> {lvalue},IECore::TypeId)

isInstanceOf( (CompoundObjectParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedObjectParameter<IECore::CompoundObject> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CompoundObjectParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedObjectParameter<IECore::CompoundObject> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CompoundObjectParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedObjectParameter<IECore::CompoundObject> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validTypes (self, *args, **kwargs):
      '''
validTypes( (ObjectParameter)arg1) -> list :

    C++ signature :
        boost::python::list validTypes(IECore::ObjectParameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (CompoundObjectParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedObjectParameter<IECore::CompoundObject>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def CompoundParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='')
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[])
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[], boost::intrusive_ptr<IECore::CompoundObject> userData=None)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[], boost::intrusive_ptr<IECore::CompoundObject> userData=None, bool adoptChildPresets=True)

'''      
    ...

class CompoundParameter:
    def addParameter (self, *args, **kwargs):
      '''
addParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void addParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)'''
    ...
    def addParameters (self, *args, **kwargs):
      '''
addParameters( (CompoundParameter)arg1, (list)arg2) -> None :

    C++ signature :
        void addParameters(IECore::CompoundParameter {lvalue},boost::python::list)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def clearParameters (self, *args, **kwargs):
      '''
clearParameters( (CompoundParameter)arg1) -> None :

    C++ signature :
        void clearParameters(IECore::CompoundParameter {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundParameter)arg1, (object)arg2) -> bool :

    C++ signature :
        bool has_key(IECore::CompoundParameter,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insertParameter (self, *args, **kwargs):
      '''
insertParameter( (CompoundParameter)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void insertParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>,boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (CompoundParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundParameter {lvalue},IECore::TypeId)

isInstanceOf( (CompoundParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::CompoundParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list items(IECore::CompoundParameter)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list keys(IECore::CompoundParameter)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameter (self, *args, **kwargs):
      '''
parameter( (CompoundParameter)arg1, (str)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> parameter(IECore::CompoundParameter {lvalue},char const*)'''
    ...
    def parameterPath (self, *args, **kwargs):
      '''
parameterPath( (CompoundParameter)arg1, (object)arg2) -> list :

    C++ signature :
        boost::python::list parameterPath(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def removeParameter (self, *args, **kwargs):
      '''
removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)

removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for CompoundParameter objects. Uses introspection on the given value to define
	how the value will be assigned to the CompoundParameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (CompoundParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::CompoundParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (CompoundParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::CompoundParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (CompoundParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::CompoundParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list values(IECore::CompoundParameter)'''
    ...

def CompoundStream (*args):
      '''

'''      
    ...

class CompoundStream:
    def flush (self):
      '''None'''
    ...
    def write (self, l):
      '''None'''
    ...

def CompoundVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='')
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[])
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[], boost::intrusive_ptr<IECore::CompoundObject> userData=None)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[], boost::intrusive_ptr<IECore::CompoundObject> userData=None, bool adoptChildPresets=True)

'''      
    ...

class CompoundVectorParameter:
    def _CompoundVectorParameter__testParameterType (self, parameter):
      '''None'''
    ...
    def addParameter (self, parameter):
      '''None'''
    ...
    def addParameters (self, parameters):
      '''None'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def clearParameters (self, *args, **kwargs):
      '''
clearParameters( (CompoundParameter)arg1) -> None :

    C++ signature :
        void clearParameters(IECore::CompoundParameter {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundParameter)arg1, (object)arg2) -> bool :

    C++ signature :
        bool has_key(IECore::CompoundParameter,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def insertParameter (self, parameter, other):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list items(IECore::CompoundParameter)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list keys(IECore::CompoundParameter)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameter (self, *args, **kwargs):
      '''
parameter( (CompoundParameter)arg1, (str)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> parameter(IECore::CompoundParameter {lvalue},char const*)'''
    ...
    def parameterPath (self, *args, **kwargs):
      '''
parameterPath( (CompoundParameter)arg1, (object)arg2) -> list :

    C++ signature :
        boost::python::list parameterPath(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def removeParameter (self, *args, **kwargs):
      '''
removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)

removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for CompoundParameter objects. Uses introspection on the given value to define
	how the value will be assigned to the CompoundParameter object.
	'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, value):
      '''None'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list values(IECore::CompoundParameter)'''
    ...

def ConfigLoader (*args):
      '''

'''      
    ...

def Constant (*args):
      '''

'''      
    ...

def Converter (*args):
      '''

'''      
    ...

class Converter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Converter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Converter {lvalue},IECore::TypeId)

isInstanceOf( (Converter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Converter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Converter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Converter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Converter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Converter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def CubicBasisd (*args):
      '''
__init__(_object*, IECore::StandardCubicBasis)
__init__(_object*, Imath_3_1::Matrix44<double>, unsigned int)

'''      
    ...

class CubicBasisd:
    def bSpline (self, *args, **kwargs):
      '''
bSpline() -> CubicBasisd :

    C++ signature :
        IECore::CubicBasis<double> bSpline()'''
    ...
    def bezier (self, *args, **kwargs):
      '''
bezier() -> CubicBasisd :

    C++ signature :
        IECore::CubicBasis<double> bezier()'''
    ...
    def catmullRom (self, *args, **kwargs):
      '''
catmullRom() -> CubicBasisd :

    C++ signature :
        IECore::CubicBasis<double> catmullRom()'''
    ...
    def coefficients (self, *args, **kwargs):
      '''
coefficients( (CubicBasisd)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple coefficients(IECore::CubicBasis<double>,double)'''
    ...
    def constant (self, *args, **kwargs):
      '''
constant() -> CubicBasisd :

    C++ signature :
        IECore::CubicBasis<double> constant()'''
    ...
    def derivative (self, *args, **kwargs):
      '''
derivative( (CubicBasisd)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5, (float)arg6) -> float :

    C++ signature :
        double derivative(IECore::CubicBasis<double> {lvalue},double,double,double,double,double)

derivative( (CubicBasisd)arg1, (float)arg2, (V2f)arg3, (V2f)arg4, (V2f)arg5, (V2f)arg6) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> derivative(IECore::CubicBasis<double> {lvalue},float,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>)

derivative( (CubicBasisd)arg1, (float)arg2, (V3f)arg3, (V3f)arg4, (V3f)arg5, (V3f)arg6) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> derivative(IECore::CubicBasis<double> {lvalue},float,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>)

derivative( (CubicBasisd)arg1, (float)arg2, (V2d)arg3, (V2d)arg4, (V2d)arg5, (V2d)arg6) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> derivative(IECore::CubicBasis<double> {lvalue},double,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>)

derivative( (CubicBasisd)arg1, (float)arg2, (V3d)arg3, (V3d)arg4, (V3d)arg5, (V3d)arg6) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> derivative(IECore::CubicBasis<double> {lvalue},double,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>)'''
    ...
    def derivativeCoefficients (self, *args, **kwargs):
      '''
derivativeCoefficients( (CubicBasisd)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple derivativeCoefficients(IECore::CubicBasis<double>,double)'''
    ...
    def integral (self, *args, **kwargs):
      '''
integral( (CubicBasisd)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5, (float)arg6, (float)arg7) -> float :

    C++ signature :
        double integral(IECore::CubicBasis<double> {lvalue},double,double,double,double,double,double)

integral( (CubicBasisd)arg1, (float)arg2, (float)arg3, (V2f)arg4, (V2f)arg5, (V2f)arg6, (V2f)arg7) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> integral(IECore::CubicBasis<double> {lvalue},float,float,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>)

integral( (CubicBasisd)arg1, (float)arg2, (float)arg3, (V3f)arg4, (V3f)arg5, (V3f)arg6, (V3f)arg7) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> integral(IECore::CubicBasis<double> {lvalue},float,float,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>)

integral( (CubicBasisd)arg1, (float)arg2, (float)arg3, (V2d)arg4, (V2d)arg5, (V2d)arg6, (V2d)arg7) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> integral(IECore::CubicBasis<double> {lvalue},double,double,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>)

integral( (CubicBasisd)arg1, (float)arg2, (float)arg3, (V3d)arg4, (V3d)arg5, (V3d)arg6, (V3d)arg7) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> integral(IECore::CubicBasis<double> {lvalue},double,double,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>)'''
    ...
    def integralCoefficients (self, *args, **kwargs):
      '''
integralCoefficients( (CubicBasisd)arg1, (float)arg2, (float)arg3) -> tuple :

    C++ signature :
        boost::python::tuple integralCoefficients(IECore::CubicBasis<double>,double,double)'''
    ...
    def linear (self, *args, **kwargs):
      '''
linear() -> CubicBasisd :

    C++ signature :
        IECore::CubicBasis<double> linear()'''
    ...
    def matrix (self, *args, **kwargs):
      '''None'''
    ...
    def numCoefficients (self, *args, **kwargs):
      '''
numCoefficients( (CubicBasisd)arg1) -> int :

    C++ signature :
        int numCoefficients(IECore::CubicBasis<double> {lvalue})'''
    ...
    def standardBasis (self, *args, **kwargs):
      '''
standardBasis( (CubicBasisd)arg1) -> StandardCubicBasis :

    C++ signature :
        IECore::StandardCubicBasis standardBasis(IECore::CubicBasis<double> {lvalue})'''
    ...
    def step (self, *args, **kwargs):
      '''None'''
    ...

def CubicBasisf (*args):
      '''
__init__(_object*, IECore::StandardCubicBasis)
__init__(_object*, Imath_3_1::Matrix44<float>, unsigned int)

'''      
    ...

class CubicBasisf:
    def bSpline (self, *args, **kwargs):
      '''
bSpline() -> CubicBasisf :

    C++ signature :
        IECore::CubicBasis<float> bSpline()'''
    ...
    def bezier (self, *args, **kwargs):
      '''
bezier() -> CubicBasisf :

    C++ signature :
        IECore::CubicBasis<float> bezier()'''
    ...
    def catmullRom (self, *args, **kwargs):
      '''
catmullRom() -> CubicBasisf :

    C++ signature :
        IECore::CubicBasis<float> catmullRom()'''
    ...
    def coefficients (self, *args, **kwargs):
      '''
coefficients( (CubicBasisf)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple coefficients(IECore::CubicBasis<float>,float)'''
    ...
    def constant (self, *args, **kwargs):
      '''
constant() -> CubicBasisf :

    C++ signature :
        IECore::CubicBasis<float> constant()'''
    ...
    def derivative (self, *args, **kwargs):
      '''
derivative( (CubicBasisf)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5, (float)arg6) -> float :

    C++ signature :
        float derivative(IECore::CubicBasis<float> {lvalue},float,float,float,float,float)

derivative( (CubicBasisf)arg1, (float)arg2, (V2f)arg3, (V2f)arg4, (V2f)arg5, (V2f)arg6) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> derivative(IECore::CubicBasis<float> {lvalue},float,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>)

derivative( (CubicBasisf)arg1, (float)arg2, (V3f)arg3, (V3f)arg4, (V3f)arg5, (V3f)arg6) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> derivative(IECore::CubicBasis<float> {lvalue},float,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>)

derivative( (CubicBasisf)arg1, (float)arg2, (V2d)arg3, (V2d)arg4, (V2d)arg5, (V2d)arg6) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> derivative(IECore::CubicBasis<float> {lvalue},double,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>)

derivative( (CubicBasisf)arg1, (float)arg2, (V3d)arg3, (V3d)arg4, (V3d)arg5, (V3d)arg6) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> derivative(IECore::CubicBasis<float> {lvalue},double,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>)'''
    ...
    def derivativeCoefficients (self, *args, **kwargs):
      '''
derivativeCoefficients( (CubicBasisf)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple derivativeCoefficients(IECore::CubicBasis<float>,float)'''
    ...
    def integral (self, *args, **kwargs):
      '''
integral( (CubicBasisf)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5, (float)arg6, (float)arg7) -> float :

    C++ signature :
        float integral(IECore::CubicBasis<float> {lvalue},float,float,float,float,float,float)

integral( (CubicBasisf)arg1, (float)arg2, (float)arg3, (V2f)arg4, (V2f)arg5, (V2f)arg6, (V2f)arg7) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> integral(IECore::CubicBasis<float> {lvalue},float,float,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>,Imath_3_1::Vec2<float>)

integral( (CubicBasisf)arg1, (float)arg2, (float)arg3, (V3f)arg4, (V3f)arg5, (V3f)arg6, (V3f)arg7) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> integral(IECore::CubicBasis<float> {lvalue},float,float,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>,Imath_3_1::Vec3<float>)

integral( (CubicBasisf)arg1, (float)arg2, (float)arg3, (V2d)arg4, (V2d)arg5, (V2d)arg6, (V2d)arg7) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> integral(IECore::CubicBasis<float> {lvalue},double,double,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>,Imath_3_1::Vec2<double>)

integral( (CubicBasisf)arg1, (float)arg2, (float)arg3, (V3d)arg4, (V3d)arg5, (V3d)arg6, (V3d)arg7) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> integral(IECore::CubicBasis<float> {lvalue},double,double,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>,Imath_3_1::Vec3<double>)'''
    ...
    def integralCoefficients (self, *args, **kwargs):
      '''
integralCoefficients( (CubicBasisf)arg1, (float)arg2, (float)arg3) -> tuple :

    C++ signature :
        boost::python::tuple integralCoefficients(IECore::CubicBasis<float>,float,float)'''
    ...
    def linear (self, *args, **kwargs):
      '''
linear() -> CubicBasisf :

    C++ signature :
        IECore::CubicBasis<float> linear()'''
    ...
    def matrix (self, *args, **kwargs):
      '''None'''
    ...
    def numCoefficients (self, *args, **kwargs):
      '''
numCoefficients( (CubicBasisf)arg1) -> int :

    C++ signature :
        int numCoefficients(IECore::CubicBasis<float> {lvalue})'''
    ...
    def standardBasis (self, *args, **kwargs):
      '''
standardBasis( (CubicBasisf)arg1) -> StandardCubicBasis :

    C++ signature :
        IECore::StandardCubicBasis standardBasis(IECore::CubicBasis<float> {lvalue})'''
    ...
    def step (self, *args, **kwargs):
      '''None'''
    ...

def Data (*args):
      '''

'''      
    ...

class Data:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Data)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Data {lvalue},IECore::TypeId)

isInstanceOf( (Data)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Data {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Data)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Data {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Data)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Data {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def DataCastOp (*args):
      '''
__init__(_object*)

'''      
    ...

class DataCastOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DataCastOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataCastOp {lvalue},IECore::TypeId)

isInstanceOf( (DataCastOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataCastOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DataCastOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::DataCastOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DataCastOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::DataCastOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def DataConvertOp (*args):
      '''
__init__(_object*)

'''      
    ...

class DataConvertOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DataConvertOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataConvertOp {lvalue},IECore::TypeId)

isInstanceOf( (DataConvertOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataConvertOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DataConvertOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::DataConvertOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DataConvertOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::DataConvertOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def DataInterleaveOp (*args):
      '''
__init__(_object*)

'''      
    ...

class DataInterleaveOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DataInterleaveOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataInterleaveOp {lvalue},IECore::TypeId)

isInstanceOf( (DataInterleaveOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataInterleaveOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DataInterleaveOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::DataInterleaveOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DataInterleaveOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::DataInterleaveOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def DataPromoteOp (*args):
      '''
__init__(_object*)

'''      
    ...

class DataPromoteOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DataPromoteOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataPromoteOp {lvalue},IECore::TypeId)

isInstanceOf( (DataPromoteOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DataPromoteOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DataPromoteOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::DataPromoteOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DataPromoteOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::DataPromoteOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def DataTraits (*args):
      '''

'''      
    ...

def DateTimeData (*args):
      '''
__init__(_object*, boost::posix_time::ptime)
__init__(_object*)

'''      
    ...

class DateTimeData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DateTimeData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<boost::posix_time::ptime> {lvalue},IECore::TypeId)

isInstanceOf( (DateTimeData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<boost::posix_time::ptime> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DateTimeData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<boost::posix_time::ptime> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DateTimeData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<boost::posix_time::ptime> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def DateTimeParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class DateTimeParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (DateTimeParameter)arg1) -> object :

    C++ signature :
        boost::posix_time::ptime getTypedValue(IECore::TypedParameter<boost::posix_time::ptime> {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DateTimeParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<boost::posix_time::ptime> {lvalue},IECore::TypeId)

isInstanceOf( (DateTimeParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<boost::posix_time::ptime> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (DateTimeParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<boost::posix_time::ptime> {lvalue},boost::posix_time::ptime)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DateTimeParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<boost::posix_time::ptime> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DateTimeParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<boost::posix_time::ptime> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (DateTimeParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<boost::posix_time::ptime>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def DateTimeParameterParser (*args):
      '''

'''      
    ...

def DirNameParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class DirNameParameter:
    def CheckType (self, *args, **kwargs):
      '''None'''
    ...
    def allowEmptyString (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DirNameParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DirNameParameter {lvalue},IECore::TypeId)

isInstanceOf( (DirNameParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::DirNameParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mustExist (self, *args, **kwargs):
      '''None'''
    ...
    def mustNotExist (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DirNameParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::DirNameParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DirNameParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::DirNameParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (DirNameParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::DirNameParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def DoubleData (*args):
      '''
__init__(boost::python::api::object, double)
__init__(_object*)

'''      
    ...

class DoubleData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DoubleData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<double> {lvalue},IECore::TypeId)

isInstanceOf( (DoubleData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<double> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''Convert a string or number to a floating point number, if possible.'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''Convert a string or number to a floating point number, if possible.'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DoubleData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<double> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DoubleData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<double> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def DoubleParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, double defaultValue=0.0)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, double defaultValue=0.0, double minValue=-1.7976931348623157e+308)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, double defaultValue=0.0, double minValue=-1.7976931348623157e+308, double maxValue=1.7976931348623157e+308)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, double defaultValue=0.0, double minValue=-1.7976931348623157e+308, double maxValue=1.7976931348623157e+308, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, double defaultValue=0.0, double minValue=-1.7976931348623157e+308, double maxValue=1.7976931348623157e+308, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, double defaultValue=0.0, double minValue=-1.7976931348623157e+308, double maxValue=1.7976931348623157e+308, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class DoubleParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getNumericValue (self, *args, **kwargs):
      '''
getNumericValue( (DoubleParameter)arg1) -> float :

    C++ signature :
        double getNumericValue(IECore::NumericParameter<double> {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (DoubleParameter)arg1) -> float :

    C++ signature :
        double getTypedValue(IECore::NumericParameter<double> {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def hasMaxValue (self, *args, **kwargs):
      '''
hasMaxValue( (DoubleParameter)arg1) -> bool :

    C++ signature :
        bool hasMaxValue(IECore::NumericParameter<double> {lvalue})'''
    ...
    def hasMinValue (self, *args, **kwargs):
      '''
hasMinValue( (DoubleParameter)arg1) -> bool :

    C++ signature :
        bool hasMinValue(IECore::NumericParameter<double> {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DoubleParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NumericParameter<double> {lvalue},IECore::TypeId)

isInstanceOf( (DoubleParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NumericParameter<double> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def maxValue (self, *args, **kwargs):
      '''None'''
    ...
    def minValue (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def numericDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setNumericValue (self, *args, **kwargs):
      '''
setNumericValue( (DoubleParameter)arg1, (float)arg2) -> None :

    C++ signature :
        void setNumericValue(IECore::NumericParameter<double> {lvalue},double)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (DoubleParameter)arg1, (float)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::NumericParameter<double> {lvalue},double)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DoubleParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::NumericParameter<double> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DoubleParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::NumericParameter<double> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (DoubleParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::NumericParameter<double>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def DoubleVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class DoubleVectorData:
    def append (self, *args, **kwargs):
      '''
append( (DoubleVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (DoubleVectorData)arg1, (float)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},double)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (DoubleVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (DoubleVectorData)arg1, (float)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},double,long,long)

index( (DoubleVectorData)arg1, (float)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},double)

index( (DoubleVectorData)arg1, (float)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},double,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (DoubleVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DoubleVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (DoubleVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (DoubleVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},unsigned long)

resize( (DoubleVectorData)arg1, (int)arg2, (float)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue},unsigned long,double)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (DoubleVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (DoubleVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DoubleVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DoubleVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def DoubleVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class DoubleVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (DoubleVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<double, std::allocator<double> > getTypedValue(IECore::TypedParameter<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (DoubleVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<double, std::allocator<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (DoubleVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<double, std::allocator<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (DoubleVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<double, std::allocator<double> > > {lvalue},std::vector<double, std::allocator<double> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (DoubleVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (DoubleVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<double, std::allocator<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (DoubleVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<double, std::allocator<double> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def EmptyFrameList (*args):
      '''
__init__(_object*)

'''      
    ...

class EmptyFrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (EmptyFrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::EmptyFrameList {lvalue},IECore::TypeId)

isInstanceOf( (EmptyFrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::EmptyFrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (EmptyFrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::EmptyFrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (EmptyFrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::EmptyFrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Enum (*args):
      '''

'''      
    ...

def Exception (*args):
      '''

'''      
    ...

class Exception:
    def args (self, *args, **kwargs):
      '''None'''
    ...
    def with_traceback (self, *args, **kwargs):
      '''Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.'''
    ...

def ExclusionFrameList (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::FrameList>, boost::intrusive_ptr<IECore::FrameList>)

'''      
    ...

class ExclusionFrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def exclusionFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def frameList (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ExclusionFrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ExclusionFrameList {lvalue},IECore::TypeId)

isInstanceOf( (ExclusionFrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ExclusionFrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ExclusionFrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ExclusionFrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ExclusionFrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ExclusionFrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def FileIndexedIO (*args):
      '''
__init__(boost::python::api::object, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, boost::python::list, unsigned int)
__init__(boost::python::api::object, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, unsigned int)

'''      
    ...

class FileIndexedIO:
    def Append (self, *args, **kwargs):
      '''None'''
    ...
    def Char (self, *args, **kwargs):
      '''None'''
    ...
    def CharArray (self, *args, **kwargs):
      '''None'''
    ...
    def CreateIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def DataType (self, *args, **kwargs):
      '''None'''
    ...
    def Directory (self, *args, **kwargs):
      '''None'''
    ...
    def Double (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleArray (self, *args, **kwargs):
      '''None'''
    ...
    def Entry (self, *args, **kwargs):
      '''None'''
    ...
    def EntryType (self, *args, **kwargs):
      '''None'''
    ...
    def Exclusive (self, *args, **kwargs):
      '''None'''
    ...
    def File (self, *args, **kwargs):
      '''None'''
    ...
    def Float (self, *args, **kwargs):
      '''None'''
    ...
    def FloatArray (self, *args, **kwargs):
      '''None'''
    ...
    def Half (self, *args, **kwargs):
      '''None'''
    ...
    def HalfArray (self, *args, **kwargs):
      '''None'''
    ...
    def Int (self, *args, **kwargs):
      '''None'''
    ...
    def Int64 (self, *args, **kwargs):
      '''None'''
    ...
    def Int64Array (self, *args, **kwargs):
      '''None'''
    ...
    def IntArray (self, *args, **kwargs):
      '''None'''
    ...
    def InternedStringArray (self, *args, **kwargs):
      '''None'''
    ...
    def Invalid (self, *args, **kwargs):
      '''None'''
    ...
    def Long (self, *args, **kwargs):
      '''None'''
    ...
    def LongArray (self, *args, **kwargs):
      '''None'''
    ...
    def MissingBehaviour (self, *args, **kwargs):
      '''None'''
    ...
    def NullIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def OpenMode (self, *args, **kwargs):
      '''None'''
    ...
    def Read (self, *args, **kwargs):
      '''None'''
    ...
    def Shared (self, *args, **kwargs):
      '''None'''
    ...
    def Short (self, *args, **kwargs):
      '''None'''
    ...
    def ShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def String (self, *args, **kwargs):
      '''None'''
    ...
    def StringArray (self, *args, **kwargs):
      '''None'''
    ...
    def ThrowIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def UChar (self, *args, **kwargs):
      '''None'''
    ...
    def UCharArray (self, *args, **kwargs):
      '''None'''
    ...
    def UInt (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64 (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64Array (self, *args, **kwargs):
      '''None'''
    ...
    def UIntArray (self, *args, **kwargs):
      '''None'''
    ...
    def UShort (self, *args, **kwargs):
      '''None'''
    ...
    def UShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def Write (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)path, (list)root, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::list,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])

create( (object)path, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])'''
    ...
    def createSubdirectory (self, *args, **kwargs):
      '''
createSubdirectory( (IndexedIO)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> createSubdirectory(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def currentEntryId (self, *args, **kwargs):
      '''
currentEntryId( (object)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > currentEntryId(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def directory (self, *args, **kwargs):
      '''
directory( (object)arg1, (list)path [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> directory(boost::intrusive_ptr<IECore::IndexedIO>,boost::python::list [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def entry (self, *args, **kwargs):
      '''
entry( (IndexedIO)arg1, (InternedString)arg2) -> Entry :

    C++ signature :
        IECore::IndexedIO::Entry entry(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def entryIds (self, *args, **kwargs):
      '''
entryIds( (object)arg1) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>)

entryIds( (object)arg1, (EntryType)arg2) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>,IECore::IndexedIO::EntryType)'''
    ...
    def fileName (self, *args, **kwargs):
      '''
fileName( (FileIndexedIO)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > fileName(IECore::FileIndexedIO {lvalue})'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FileIndexedIO)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileIndexedIO {lvalue},IECore::TypeId)

isInstanceOf( (FileIndexedIO)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileIndexedIO {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def metadata (self, *args, **kwargs):
      '''
metadata( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundData> metadata(IECore::IndexedIO {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def openMode (self, *args, **kwargs):
      '''
openMode( (IndexedIO)arg1) -> int :

    C++ signature :
        unsigned int openMode(IECore::IndexedIO {lvalue})'''
    ...
    def parentDirectory (self, *args, **kwargs):
      '''
parentDirectory( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> parentDirectory(IECore::IndexedIO {lvalue})'''
    ...
    def path (self, *args, **kwargs):
      '''
path( (object)arg1) -> list :

    C++ signature :
        boost::python::list path(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (object)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::python::api::object read(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def remove (self, *args, **kwargs):
      '''
remove( (IndexedIO)arg1, (InternedString)arg2) -> None :

    C++ signature :
        void remove(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def removeAll (self, *args, **kwargs):
      '''
removeAll( (IndexedIO)arg1) -> None :

    C++ signature :
        void removeAll(IECore::IndexedIO {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def subdirectory (self, *args, **kwargs):
      '''
subdirectory( (IndexedIO)arg1, (InternedString)name [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> subdirectory(IECore::IndexedIO {lvalue},IECore::InternedString [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FileIndexedIO)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FileIndexedIO {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FileIndexedIO)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FileIndexedIO {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def write (self, *args, **kwargs):
      '''
write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > >)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,float)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,double)

write( (IndexedIO)arg1, (InternedString)arg2, (int)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,int)

write( (IndexedIO)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def FileNameParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > extensions='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class FileNameParameter:
    def CheckType (self, *args, **kwargs):
      '''None'''
    ...
    def allowEmptyString (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def extensions (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FileNameParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileNameParameter {lvalue},IECore::TypeId)

isInstanceOf( (FileNameParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileNameParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mustExist (self, *args, **kwargs):
      '''None'''
    ...
    def mustNotExist (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FileNameParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FileNameParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FileNameParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FileNameParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (FileNameParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::FileNameParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def FileSequence (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, boost::intrusive_ptr<IECore::FrameList>)

'''      
    ...

class FileSequence:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def clumpedFileNames (self, *args, **kwargs):
      '''
clumpedFileNames( (FileSequence)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list clumpedFileNames(IECore::FileSequence,unsigned int)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FileSequence)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FileSequence> copy(IECore::FileSequence {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def fileName (self, *args, **kwargs):
      '''None'''
    ...
    def fileNameForFrame (self, *args, **kwargs):
      '''
fileNameForFrame( (FileSequence)arg1, (int)arg2) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > fileNameForFrame(IECore::FileSequence {lvalue},long)'''
    ...
    def fileNameValidator ():
      '''None'''
    ...
    def fileNames (self, *args, **kwargs):
      '''
fileNames( (FileSequence)arg1) -> list :

    C++ signature :
        boost::python::list fileNames(IECore::FileSequence)'''
    ...
    def frameForFileName (self, *args, **kwargs):
      '''
frameForFileName( (FileSequence)arg1, (object)arg2) -> int :

    C++ signature :
        long frameForFileName(IECore::FileSequence {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def frameList (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getPadding (self, *args, **kwargs):
      '''
getPadding( (FileSequence)arg1) -> int :

    C++ signature :
        unsigned int getPadding(IECore::FileSequence {lvalue})'''
    ...
    def getPrefix (self, *args, **kwargs):
      '''
getPrefix( (FileSequence)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getPrefix(IECore::FileSequence {lvalue})'''
    ...
    def getSuffix (self, *args, **kwargs):
      '''
getSuffix( (FileSequence)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getSuffix(IECore::FileSequence {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FileSequence)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileSequence {lvalue},IECore::TypeId)

isInstanceOf( (FileSequence)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileSequence {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mapTo (self, *args, **kwargs):
      '''
mapTo( (FileSequence)arg1, (FileSequence)arg2 [, (bool)arg3]) -> object :

    C++ signature :
        boost::python::api::object mapTo(IECore::FileSequence,IECore::FileSequence const* [,bool])'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPadding (self, *args, **kwargs):
      '''
setPadding( (FileSequence)arg1, (int)arg2) -> None :

    C++ signature :
        void setPadding(IECore::FileSequence {lvalue},unsigned int)'''
    ...
    def setPrefix (self, *args, **kwargs):
      '''
setPrefix( (FileSequence)arg1, (object)arg2) -> None :

    C++ signature :
        void setPrefix(IECore::FileSequence {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setSuffix (self, *args, **kwargs):
      '''
setSuffix( (FileSequence)arg1, (object)arg2) -> None :

    C++ signature :
        void setSuffix(IECore::FileSequence {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FileSequence)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FileSequence {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FileSequence)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FileSequence {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def FileSequenceFunctions (*args):
      '''

'''      
    ...

def FileSequenceParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='')
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None, boost::python::api::object extensions=[])
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None, boost::python::api::object extensions=[], int minSequenceSize=2)

'''      
    ...

class FileSequenceParameter:
    def CheckType (self, *args, **kwargs):
      '''None'''
    ...
    def allowEmptyString (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def extensions (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getFileSequenceValue (self, *args, **kwargs):
      '''
getFileSequenceValue( (FileSequenceParameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FileSequence> getFileSequenceValue(IECore::FileSequenceParameter {lvalue})

getFileSequenceValue( (FileSequenceParameter)arg1, (StringData)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FileSequence> getFileSequenceValue(IECore::FileSequenceParameter {lvalue},IECore::TypedData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*)'''
    ...
    def getMinSequenceSize (self, *args, **kwargs):
      '''
getMinSequenceSize( (FileSequenceParameter)arg1) -> int :

    C++ signature :
        unsigned long getMinSequenceSize(IECore::FileSequenceParameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FileSequenceParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileSequenceParameter {lvalue},IECore::TypeId)

isInstanceOf( (FileSequenceParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileSequenceParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mustExist (self, *args, **kwargs):
      '''None'''
    ...
    def mustNotExist (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setFileSequenceValue (self, *args, **kwargs):
      '''
setFileSequenceValue( (FileSequenceParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setFileSequenceValue(IECore::FileSequenceParameter {lvalue},boost::intrusive_ptr<IECore::FileSequence const>)'''
    ...
    def setMinSequenceSize (self, *args, **kwargs):
      '''
setMinSequenceSize( (FileSequenceParameter)arg1, (int)arg2) -> None :

    C++ signature :
        void setMinSequenceSize(IECore::FileSequenceParameter {lvalue},unsigned long)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FileSequenceParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FileSequenceParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FileSequenceParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FileSequenceParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (FileSequenceParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::FileSequenceParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def FileSequenceVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[])
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[], bool allowEmptyList=True)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[], bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[], bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[], bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[], bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue=[], bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None, boost::python::api::object extensions=[])

'''      
    ...

class FileSequenceVectorParameter:
    def CheckType (self, *args, **kwargs):
      '''None'''
    ...
    def allowEmptyList (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def extensions (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getFileSequenceValues (self, *args, **kwargs):
      '''
getFileSequenceValues( (FileSequenceVectorParameter)arg1) -> list :

    C++ signature :
        boost::python::list getFileSequenceValues((anonymous namespace)::FileSequenceVectorParameterWrapper {lvalue})

getFileSequenceValues( (FileSequenceVectorParameter)arg1, (StringVectorData)arg2) -> list :

    C++ signature :
        boost::python::list getFileSequenceValues((anonymous namespace)::FileSequenceVectorParameterWrapper {lvalue},IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const*)'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > getTypedValue(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FileSequenceVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileSequenceVectorParameter {lvalue},IECore::TypeId)

isInstanceOf( (FileSequenceVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FileSequenceVectorParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mustExist (self, *args, **kwargs):
      '''None'''
    ...
    def mustNotExist (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setFileSequenceValues (self, *args, **kwargs):
      '''
setFileSequenceValues( (FileSequenceVectorParameter)arg1, (list)arg2) -> None :

    C++ signature :
        void setFileSequenceValues((anonymous namespace)::FileSequenceVectorParameterWrapper {lvalue},boost::python::list)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FileSequenceVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FileSequenceVectorParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FileSequenceVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FileSequenceVectorParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (FileSequenceVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::FileSequenceVectorParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def FilteredMessageHandler (*args):
      '''

'''      
    ...

class FilteredMessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def FloatData (*args):
      '''
__init__(boost::python::api::object, float)
__init__(_object*)

'''      
    ...

class FloatData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FloatData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<float> {lvalue},IECore::TypeId)

isInstanceOf( (FloatData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<float> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''Convert a string or number to a floating point number, if possible.'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''Convert a string or number to a floating point number, if possible.'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FloatData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<float> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FloatData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<float> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def FloatParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, float defaultValue=0.0)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, float defaultValue=0.0, float minValue=-3.4028234663852886e+38)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, float defaultValue=0.0, float minValue=-3.4028234663852886e+38, float maxValue=3.4028234663852886e+38)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, float defaultValue=0.0, float minValue=-3.4028234663852886e+38, float maxValue=3.4028234663852886e+38, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, float defaultValue=0.0, float minValue=-3.4028234663852886e+38, float maxValue=3.4028234663852886e+38, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, float defaultValue=0.0, float minValue=-3.4028234663852886e+38, float maxValue=3.4028234663852886e+38, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class FloatParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getNumericValue (self, *args, **kwargs):
      '''
getNumericValue( (FloatParameter)arg1) -> float :

    C++ signature :
        float getNumericValue(IECore::NumericParameter<float> {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (FloatParameter)arg1) -> float :

    C++ signature :
        float getTypedValue(IECore::NumericParameter<float> {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def hasMaxValue (self, *args, **kwargs):
      '''
hasMaxValue( (FloatParameter)arg1) -> bool :

    C++ signature :
        bool hasMaxValue(IECore::NumericParameter<float> {lvalue})'''
    ...
    def hasMinValue (self, *args, **kwargs):
      '''
hasMinValue( (FloatParameter)arg1) -> bool :

    C++ signature :
        bool hasMinValue(IECore::NumericParameter<float> {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FloatParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NumericParameter<float> {lvalue},IECore::TypeId)

isInstanceOf( (FloatParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NumericParameter<float> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def maxValue (self, *args, **kwargs):
      '''None'''
    ...
    def minValue (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def numericDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setNumericValue (self, *args, **kwargs):
      '''
setNumericValue( (FloatParameter)arg1, (float)arg2) -> None :

    C++ signature :
        void setNumericValue(IECore::NumericParameter<float> {lvalue},float)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (FloatParameter)arg1, (float)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::NumericParameter<float> {lvalue},float)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FloatParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::NumericParameter<float> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FloatParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::NumericParameter<float> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (FloatParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::NumericParameter<float>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def FloatVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class FloatVectorData:
    def append (self, *args, **kwargs):
      '''
append( (FloatVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (FloatVectorData)arg1, (float)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},float)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (FloatVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (FloatVectorData)arg1, (float)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},float,long,long)

index( (FloatVectorData)arg1, (float)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},float)

index( (FloatVectorData)arg1, (float)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},float,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (FloatVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FloatVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (FloatVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (FloatVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},unsigned long)

resize( (FloatVectorData)arg1, (int)arg2, (float)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue},unsigned long,float)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (FloatVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (FloatVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FloatVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FloatVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def FloatVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class FloatVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (FloatVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<float, std::allocator<float> > getTypedValue(IECore::TypedParameter<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FloatVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<float, std::allocator<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (FloatVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<float, std::allocator<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (FloatVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<float, std::allocator<float> > > {lvalue},std::vector<float, std::allocator<float> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FloatVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FloatVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<float, std::allocator<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (FloatVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<float, std::allocator<float> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def FormattedParameterHelp (*args):
      '''

'''      
    ...

def Formatter (*args):
      '''

'''      
    ...

class Formatter:
    def heading (self, name):
      '''None'''
    ...
    def indent (self):
      '''None'''
    ...
    def paragraph (self, name):
      '''None'''
    ...
    def unindent (self):
      '''None'''
    ...

def FrameList (*args):
      '''

'''      
    ...

class FrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FrameList {lvalue},IECore::TypeId)

isInstanceOf( (FrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def FrameListParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='')
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyList=True)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyList=True, boost::python::dict presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyList=True, boost::python::dict presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue='', bool allowEmptyList=True, boost::python::dict presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class FrameListParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getFrameListValue (self, *args, **kwargs):
      '''
getFrameListValue( (FrameListParameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> getFrameListValue(IECore::FrameListParameter {lvalue})

getFrameListValue( (FrameListParameter)arg1, (StringData)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> getFrameListValue(IECore::FrameListParameter {lvalue},IECore::TypedData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const*)'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FrameListParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FrameListParameter {lvalue},IECore::TypeId)

isInstanceOf( (FrameListParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FrameListParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setFrameListValue (self, *args, **kwargs):
      '''
setFrameListValue( (FrameListParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setFrameListValue(IECore::FrameListParameter {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FrameListParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FrameListParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FrameListParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FrameListParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (FrameListParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::FrameListParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def FrameRange (*args):
      '''
__init__(_object*, long start, long end)
__init__(_object*, long start, long end, long step=1)

'''      
    ...

class FrameRange:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def end (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FrameRange)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FrameRange {lvalue},IECore::TypeId)

isInstanceOf( (FrameRange)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FrameRange {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def start (self, *args, **kwargs):
      '''None'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def step (self, *args, **kwargs):
      '''None'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FrameRange)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FrameRange {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FrameRange)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FrameRange {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def FromCoreConverter (*args):
      '''

'''      
    ...

class FromCoreConverter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (FromCoreConverter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FromCoreConverter {lvalue},IECore::TypeId)

isInstanceOf( (FromCoreConverter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::FromCoreConverter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def srcParameter (self, *args, **kwargs):
      '''
srcParameter( (FromCoreConverter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::ObjectParameter> srcParameter(IECore::FromCoreConverter {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (FromCoreConverter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::FromCoreConverter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (FromCoreConverter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::FromCoreConverter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def GeometricData (*args):
      '''
__init__(_object*)

'''      
    ...

class GeometricData:
    def Interpretation (self, *args, **kwargs):
      '''None'''
    ...

def HalfData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::half)
__init__(_object*)

'''      
    ...

class HalfData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (HalfData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::half> {lvalue},IECore::TypeId)

isInstanceOf( (HalfData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::half> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''Convert a string or number to a floating point number, if possible.'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''Convert a string or number to a floating point number, if possible.'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (HalfData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::half> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (HalfData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::half> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def HalfVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class HalfVectorData:
    def append (self, *args, **kwargs):
      '''
append( (HalfVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (HalfVectorData)arg1, (float)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},Imath_3_1::half)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (HalfVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (HalfVectorData)arg1, (float)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},Imath_3_1::half,long,long)

index( (HalfVectorData)arg1, (float)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},Imath_3_1::half)

index( (HalfVectorData)arg1, (float)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},Imath_3_1::half,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (HalfVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (HalfVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},IECore::TypeId)

isInstanceOf( (HalfVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (HalfVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},unsigned long)

resize( (HalfVectorData)arg1, (int)arg2, (float)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue},unsigned long,Imath_3_1::half)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (HalfVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (HalfVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (HalfVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (HalfVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def HeaderGenerator (*args):
      '''

'''      
    ...

class HeaderGenerator:
    def header (self, *args, **kwargs):
      '''
header() -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> header()'''
    ...

def IgnoredExceptions (*args):
      '''

'''      
    ...

class IgnoredExceptions:

def IndexedIO (*args):
      '''

'''      
    ...

class IndexedIO:
    def Append (self, *args, **kwargs):
      '''None'''
    ...
    def Char (self, *args, **kwargs):
      '''None'''
    ...
    def CharArray (self, *args, **kwargs):
      '''None'''
    ...
    def CreateIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def DataType (self, *args, **kwargs):
      '''None'''
    ...
    def Directory (self, *args, **kwargs):
      '''None'''
    ...
    def Double (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleArray (self, *args, **kwargs):
      '''None'''
    ...
    def Entry (self, *args, **kwargs):
      '''None'''
    ...
    def EntryType (self, *args, **kwargs):
      '''None'''
    ...
    def Exclusive (self, *args, **kwargs):
      '''None'''
    ...
    def File (self, *args, **kwargs):
      '''None'''
    ...
    def Float (self, *args, **kwargs):
      '''None'''
    ...
    def FloatArray (self, *args, **kwargs):
      '''None'''
    ...
    def Half (self, *args, **kwargs):
      '''None'''
    ...
    def HalfArray (self, *args, **kwargs):
      '''None'''
    ...
    def Int (self, *args, **kwargs):
      '''None'''
    ...
    def Int64 (self, *args, **kwargs):
      '''None'''
    ...
    def Int64Array (self, *args, **kwargs):
      '''None'''
    ...
    def IntArray (self, *args, **kwargs):
      '''None'''
    ...
    def InternedStringArray (self, *args, **kwargs):
      '''None'''
    ...
    def Invalid (self, *args, **kwargs):
      '''None'''
    ...
    def Long (self, *args, **kwargs):
      '''None'''
    ...
    def LongArray (self, *args, **kwargs):
      '''None'''
    ...
    def MissingBehaviour (self, *args, **kwargs):
      '''None'''
    ...
    def NullIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def OpenMode (self, *args, **kwargs):
      '''None'''
    ...
    def Read (self, *args, **kwargs):
      '''None'''
    ...
    def Shared (self, *args, **kwargs):
      '''None'''
    ...
    def Short (self, *args, **kwargs):
      '''None'''
    ...
    def ShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def String (self, *args, **kwargs):
      '''None'''
    ...
    def StringArray (self, *args, **kwargs):
      '''None'''
    ...
    def ThrowIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def UChar (self, *args, **kwargs):
      '''None'''
    ...
    def UCharArray (self, *args, **kwargs):
      '''None'''
    ...
    def UInt (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64 (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64Array (self, *args, **kwargs):
      '''None'''
    ...
    def UIntArray (self, *args, **kwargs):
      '''None'''
    ...
    def UShort (self, *args, **kwargs):
      '''None'''
    ...
    def UShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def Write (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)path, (list)root, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::list,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])

create( (object)path, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])'''
    ...
    def createSubdirectory (self, *args, **kwargs):
      '''
createSubdirectory( (IndexedIO)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> createSubdirectory(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def currentEntryId (self, *args, **kwargs):
      '''
currentEntryId( (object)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > currentEntryId(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def directory (self, *args, **kwargs):
      '''
directory( (object)arg1, (list)path [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> directory(boost::intrusive_ptr<IECore::IndexedIO>,boost::python::list [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def entry (self, *args, **kwargs):
      '''
entry( (IndexedIO)arg1, (InternedString)arg2) -> Entry :

    C++ signature :
        IECore::IndexedIO::Entry entry(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def entryIds (self, *args, **kwargs):
      '''
entryIds( (object)arg1) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>)

entryIds( (object)arg1, (EntryType)arg2) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>,IECore::IndexedIO::EntryType)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (IndexedIO)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::IndexedIO {lvalue},IECore::TypeId)

isInstanceOf( (IndexedIO)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::IndexedIO {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def metadata (self, *args, **kwargs):
      '''
metadata( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundData> metadata(IECore::IndexedIO {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def openMode (self, *args, **kwargs):
      '''
openMode( (IndexedIO)arg1) -> int :

    C++ signature :
        unsigned int openMode(IECore::IndexedIO {lvalue})'''
    ...
    def parentDirectory (self, *args, **kwargs):
      '''
parentDirectory( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> parentDirectory(IECore::IndexedIO {lvalue})'''
    ...
    def path (self, *args, **kwargs):
      '''
path( (object)arg1) -> list :

    C++ signature :
        boost::python::list path(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (object)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::python::api::object read(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def remove (self, *args, **kwargs):
      '''
remove( (IndexedIO)arg1, (InternedString)arg2) -> None :

    C++ signature :
        void remove(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def removeAll (self, *args, **kwargs):
      '''
removeAll( (IndexedIO)arg1) -> None :

    C++ signature :
        void removeAll(IECore::IndexedIO {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def subdirectory (self, *args, **kwargs):
      '''
subdirectory( (IndexedIO)arg1, (InternedString)name [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> subdirectory(IECore::IndexedIO {lvalue},IECore::InternedString [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (IndexedIO)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::IndexedIO {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (IndexedIO)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::IndexedIO {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def write (self, *args, **kwargs):
      '''
write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > >)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,float)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,double)

write( (IndexedIO)arg1, (InternedString)arg2, (int)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,int)

write( (IndexedIO)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def IndexedIOAlgo (*args):
      '''

'''      
    ...

def Int64Data (*args):
      '''
__init__(boost::python::api::object, long)
__init__(_object*)

'''      
    ...

class Int64Data:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Int64Data)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<long> {lvalue},IECore::TypeId)

isInstanceOf( (Int64Data)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<long> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Int64Data)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<long> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Int64Data)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<long> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def Int64VectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class Int64VectorData:
    def append (self, *args, **kwargs):
      '''
append( (Int64VectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (Int64VectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},long)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (Int64VectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (Int64VectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},long,long,long)

index( (Int64VectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},long)

index( (Int64VectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},long,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (Int64VectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Int64VectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},IECore::TypeId)

isInstanceOf( (Int64VectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (Int64VectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},unsigned long)

resize( (Int64VectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue},unsigned long,long)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (Int64VectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Int64VectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Int64VectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Int64VectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<long, std::allocator<long> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def IntData (*args):
      '''
__init__(boost::python::api::object, int)
__init__(_object*)

'''      
    ...

class IntData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (IntData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<int> {lvalue},IECore::TypeId)

isInstanceOf( (IntData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<int> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (IntData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<int> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (IntData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<int> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def IntParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, int defaultValue=0)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, int defaultValue=0, int minValue=-2147483648)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, int defaultValue=0, int minValue=-2147483648, int maxValue=2147483647)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, int defaultValue=0, int minValue=-2147483648, int maxValue=2147483647, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, int defaultValue=0, int minValue=-2147483648, int maxValue=2147483647, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, int defaultValue=0, int minValue=-2147483648, int maxValue=2147483647, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class IntParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getNumericValue (self, *args, **kwargs):
      '''
getNumericValue( (IntParameter)arg1) -> int :

    C++ signature :
        int getNumericValue(IECore::NumericParameter<int> {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (IntParameter)arg1) -> int :

    C++ signature :
        int getTypedValue(IECore::NumericParameter<int> {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def hasMaxValue (self, *args, **kwargs):
      '''
hasMaxValue( (IntParameter)arg1) -> bool :

    C++ signature :
        bool hasMaxValue(IECore::NumericParameter<int> {lvalue})'''
    ...
    def hasMinValue (self, *args, **kwargs):
      '''
hasMinValue( (IntParameter)arg1) -> bool :

    C++ signature :
        bool hasMinValue(IECore::NumericParameter<int> {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (IntParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NumericParameter<int> {lvalue},IECore::TypeId)

isInstanceOf( (IntParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NumericParameter<int> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def maxValue (self, *args, **kwargs):
      '''None'''
    ...
    def minValue (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def numericDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setNumericValue (self, *args, **kwargs):
      '''
setNumericValue( (IntParameter)arg1, (int)arg2) -> None :

    C++ signature :
        void setNumericValue(IECore::NumericParameter<int> {lvalue},int)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (IntParameter)arg1, (int)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::NumericParameter<int> {lvalue},int)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (IntParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::NumericParameter<int> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (IntParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::NumericParameter<int> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (IntParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::NumericParameter<int>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def IntVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class IntVectorData:
    def append (self, *args, **kwargs):
      '''
append( (IntVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (IntVectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},int)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (IntVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (IntVectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},int,long,long)

index( (IntVectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},int)

index( (IntVectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},int,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (IntVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (IntVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},IECore::TypeId)

isInstanceOf( (IntVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (IntVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},unsigned long)

resize( (IntVectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue},unsigned long,int)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (IntVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (IntVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (IntVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (IntVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def IntVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class IntVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (IntVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<int, std::allocator<int> > getTypedValue(IECore::TypedParameter<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (IntVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<int, std::allocator<int> > > {lvalue},IECore::TypeId)

isInstanceOf( (IntVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<int, std::allocator<int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (IntVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<int, std::allocator<int> > > {lvalue},std::vector<int, std::allocator<int> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (IntVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (IntVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<int, std::allocator<int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (IntVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<int, std::allocator<int> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def InternedString (*args):
      '''
__init__(_object*, long)
__init__(_object*, IECore::InternedString)
__init__(_object*, char const*)
__init__(_object*)

'''      
    ...

class InternedString:
    def numUniqueStrings (self, *args, **kwargs):
      '''
numUniqueStrings() -> int :

    C++ signature :
        unsigned long numUniqueStrings()'''
    ...
    def value (self, *args, **kwargs):
      '''
value( (InternedString)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > value(IECore::InternedString {lvalue})'''
    ...

def InternedStringData (*args):
      '''
__init__(boost::python::api::object, IECore::InternedString)
__init__(_object*)

'''      
    ...

class InternedStringData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (InternedStringData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::InternedString> {lvalue},IECore::TypeId)

isInstanceOf( (InternedStringData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::InternedString> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (InternedStringData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::InternedString> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (InternedStringData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::InternedString> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def InternedStringVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class InternedStringVectorData:
    def append (self, *args, **kwargs):
      '''
append( (InternedStringVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (InternedStringVectorData)arg1, (InternedString)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},IECore::InternedString)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (InternedStringVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (InternedStringVectorData)arg1, (InternedString)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},IECore::InternedString,long,long)

index( (InternedStringVectorData)arg1, (InternedString)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},IECore::InternedString)

index( (InternedStringVectorData)arg1, (InternedString)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},IECore::InternedString,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (InternedStringVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (InternedStringVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},IECore::TypeId)

isInstanceOf( (InternedStringVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (InternedStringVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},unsigned long)

resize( (InternedStringVectorData)arg1, (int)arg2, (InternedString)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue},unsigned long,IECore::InternedString)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (InternedStringVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (InternedStringVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (InternedStringVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def InverseDistanceWeightedInterpolationV2dV2d (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV2dV2d:

def InverseDistanceWeightedInterpolationV2dd (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV2dd:

def InverseDistanceWeightedInterpolationV2fV2f (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV2fV2f:

def InverseDistanceWeightedInterpolationV2ff (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV2ff:

def InverseDistanceWeightedInterpolationV3dV3d (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV3dV3d:

def InverseDistanceWeightedInterpolationV3dd (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV3dd:

def InverseDistanceWeightedInterpolationV3fV3f (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV3fV3f:

def InverseDistanceWeightedInterpolationV3ff (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > >, boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >, unsigned int)

'''      
    ...

class InverseDistanceWeightedInterpolationV3ff:

def LRUCache (*args):
      '''
__init__(_object*, boost::python::api::object getter, boost::python::api::object removalCallback, unsigned long maxCost)
__init__(_object*, boost::python::api::object getter, unsigned long maxCost=500)

'''      
    ...

class LRUCache:
    def cached (self, *args, **kwargs):
      '''
cached( (LRUCache)arg1, (object)arg2) -> bool :

    C++ signature :
        bool cached((anonymous namespace)::PythonLRUCache {lvalue},boost::python::api::object)'''
    ...
    def clear (self, *args, **kwargs):
      '''
clear( (LRUCache)arg1) -> None :

    C++ signature :
        void clear((anonymous namespace)::PythonLRUCache {lvalue})'''
    ...
    def currentCost (self, *args, **kwargs):
      '''
currentCost( (LRUCache)arg1) -> int :

    C++ signature :
        unsigned long currentCost((anonymous namespace)::PythonLRUCache {lvalue})'''
    ...
    def erase (self, *args, **kwargs):
      '''
erase( (LRUCache)arg1, (object)arg2) -> bool :

    C++ signature :
        bool erase((anonymous namespace)::PythonLRUCache {lvalue},boost::python::api::object)'''
    ...
    def get (self, *args, **kwargs):
      '''
get( (LRUCache)arg1, (object)arg2) -> object :

    C++ signature :
        boost::python::api::object get((anonymous namespace)::PythonLRUCache {lvalue},boost::python::api::object)'''
    ...
    def getMaxCost (self, *args, **kwargs):
      '''
getMaxCost( (LRUCache)arg1) -> int :

    C++ signature :
        unsigned long getMaxCost((anonymous namespace)::PythonLRUCache {lvalue})'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (LRUCache)arg1, (object)arg2, (object)arg3, (int)arg4) -> bool :

    C++ signature :
        bool set((anonymous namespace)::PythonLRUCache {lvalue},boost::python::api::object,boost::python::api::object,unsigned long)'''
    ...
    def setMaxCost (self, *args, **kwargs):
      '''
setMaxCost( (LRUCache)arg1, (int)arg2) -> None :

    C++ signature :
        void setMaxCost((anonymous namespace)::PythonLRUCache {lvalue},unsigned long)'''
    ...

def LayeredDict (*args):
      '''

'''      
    ...

class LayeredDict:
    def get (self, key, defaultValue):
      '''None'''
    ...
    def keys (self):
      '''None'''
    ...

def LensModel (*args):
      '''

'''      
    ...

class LensModel:
    def Distort (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def Undistort (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def bounds (self, *args, **kwargs):
      '''
bounds( (LensModel)arg1, (int)arg2, (Box2i)arg3, (int)arg4, (int)arg5) -> Box2i :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec2<int> > bounds(IECore::LensModel {lvalue},int,Imath_3_1::Box<Imath_3_1::Vec2<int> >,int,int)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::LensModel> create(boost::intrusive_ptr<IECore::CompoundObject const>)

create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::LensModel> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::LensModel> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def distort (self, *args, **kwargs):
      '''
distort( (LensModel)arg1, (V2d)arg2) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> distort(IECore::LensModel {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (LensModel)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::LensModel {lvalue},IECore::TypeId)

isInstanceOf( (LensModel)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::LensModel {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def lensModels (self, *args, **kwargs):
      '''
lensModels() -> list :

    C++ signature :
        boost::python::list lensModels()'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (LensModel)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::LensModel {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (LensModel)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::LensModel {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def undistort (self, *args, **kwargs):
      '''
undistort( (LensModel)arg1, (V2d)arg2) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> undistort(IECore::LensModel {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (LensModel)arg1) -> None :

    C++ signature :
        void validate(IECore::LensModel {lvalue})'''
    ...

def LevelFilteredMessageHandler (*args):
      '''
__init__(boost::python::api::object, boost::intrusive_ptr<IECore::MessageHandler>, IECore::MessageHandler::Level)

'''      
    ...

class LevelFilteredMessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def defaultLevel (self, *args, **kwargs):
      '''
defaultLevel() -> Level :

    C++ signature :
        IECore::MessageHandler::Level defaultLevel()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def getLevel (self, *args, **kwargs):
      '''
getLevel( (LevelFilteredMessageHandler)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level getLevel(IECore::LevelFilteredMessageHandler {lvalue})'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def setLevel (self, *args, **kwargs):
      '''
setLevel( (LevelFilteredMessageHandler)arg1, (Level)arg2) -> None :

    C++ signature :
        void setLevel(IECore::LevelFilteredMessageHandler {lvalue},IECore::MessageHandler::Level)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def LevenbergMarquardtd (*args):
      '''
__init__(_object*)

'''      
    ...

class LevenbergMarquardtd:
    def ErrorFn (self, *args, **kwargs):
      '''None'''
    ...
    def Status (self, *args, **kwargs):
      '''None'''
    ...
    def getMaxCalls (self, *args, **kwargs):
      '''
getMaxCalls( (LevenbergMarquardtd)arg1) -> int :

    C++ signature :
        unsigned int getMaxCalls(IECorePython::LevenbergMarquardtWrapper<double> {lvalue})'''
    ...
    def getParameters (self, *args, **kwargs):
      '''
getParameters( (LevenbergMarquardtd)arg1) -> tuple :

    C++ signature :
        boost::python::tuple getParameters(IECorePython::LevenbergMarquardtWrapper<double> {lvalue})'''
    ...
    def setMaxCalls (self, *args, **kwargs):
      '''
setMaxCalls( (LevenbergMarquardtd)arg1, (int)arg2) -> None :

    C++ signature :
        void setMaxCalls(IECorePython::LevenbergMarquardtWrapper<double> {lvalue},unsigned int)'''
    ...
    def setParameters (self, *args, **kwargs):
      '''
setParameters( (LevenbergMarquardtd)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5, (float)arg6) -> None :

    C++ signature :
        void setParameters(IECorePython::LevenbergMarquardtWrapper<double> {lvalue},double,double,double,double,double)'''
    ...
    def solve (self, *args, **kwargs):
      '''
solve( (LevenbergMarquardtd)arg1, (object)arg2, (ErrorFn)arg3) -> Status :

    C++ signature :
        IECore::LevenbergMarquardt<double, IECorePython::LevenbergMarquardtErrorFnWrapper<double>, IECore::DefaultLevenbergMarquardtTraits>::Status solve(IECorePython::LevenbergMarquardtWrapper<double> {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >,IECorePython::LevenbergMarquardtErrorFnWrapper<double> {lvalue})'''
    ...

def LevenbergMarquardtf (*args):
      '''
__init__(_object*)

'''      
    ...

class LevenbergMarquardtf:
    def ErrorFn (self, *args, **kwargs):
      '''None'''
    ...
    def Status (self, *args, **kwargs):
      '''None'''
    ...
    def getMaxCalls (self, *args, **kwargs):
      '''
getMaxCalls( (LevenbergMarquardtf)arg1) -> int :

    C++ signature :
        unsigned int getMaxCalls(IECorePython::LevenbergMarquardtWrapper<float> {lvalue})'''
    ...
    def getParameters (self, *args, **kwargs):
      '''
getParameters( (LevenbergMarquardtf)arg1) -> tuple :

    C++ signature :
        boost::python::tuple getParameters(IECorePython::LevenbergMarquardtWrapper<float> {lvalue})'''
    ...
    def setMaxCalls (self, *args, **kwargs):
      '''
setMaxCalls( (LevenbergMarquardtf)arg1, (int)arg2) -> None :

    C++ signature :
        void setMaxCalls(IECorePython::LevenbergMarquardtWrapper<float> {lvalue},unsigned int)'''
    ...
    def setParameters (self, *args, **kwargs):
      '''
setParameters( (LevenbergMarquardtf)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5, (float)arg6) -> None :

    C++ signature :
        void setParameters(IECorePython::LevenbergMarquardtWrapper<float> {lvalue},float,float,float,float,float)'''
    ...
    def solve (self, *args, **kwargs):
      '''
solve( (LevenbergMarquardtf)arg1, (object)arg2, (ErrorFn)arg3) -> Status :

    C++ signature :
        IECore::LevenbergMarquardt<float, IECorePython::LevenbergMarquardtErrorFnWrapper<float>, IECore::DefaultLevenbergMarquardtTraits>::Status solve(IECorePython::LevenbergMarquardtWrapper<float> {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >,IECorePython::LevenbergMarquardtErrorFnWrapper<float> {lvalue})'''
    ...

def LineSegment2d (*args):
      '''
__init__(_object*, Imath_3_1::Vec2<double>, Imath_3_1::Vec2<double>)
__init__(_object*, IECore::LineSegment<Imath_3_1::Vec2<double> >)
__init__(_object*)

'''      
    ...

class LineSegment2d:
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (LineSegment2d)arg1, (V2d)arg2) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> closestPointTo(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def dimensions (self, *args, **kwargs):
      '''
dimensions() -> int :

    C++ signature :
        unsigned int dimensions()'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LineSegment2d)arg1) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> direction(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def distance2To (self, *args, **kwargs):
      '''
distance2To( (LineSegment2d)arg1, (V2d)arg2) -> float :

    C++ signature :
        double distance2To(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (LineSegment2d)arg1, (V2d)arg2) -> float :

    C++ signature :
        double distanceTo(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (LineSegment2d)arg1) -> float :

    C++ signature :
        double length(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def length2 (self, *args, **kwargs):
      '''
length2( (LineSegment2d)arg1) -> float :

    C++ signature :
        double length2(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def normalizedDirection (self, *args, **kwargs):
      '''
normalizedDirection( (LineSegment2d)arg1) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> normalizedDirection(IECore::LineSegment<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def p0 (self, *args, **kwargs):
      '''None'''
    ...
    def p1 (self, *args, **kwargs):
      '''None'''
    ...

def LineSegment2f (*args):
      '''
__init__(_object*, Imath_3_1::Vec2<float>, Imath_3_1::Vec2<float>)
__init__(_object*, IECore::LineSegment<Imath_3_1::Vec2<float> >)
__init__(_object*)

'''      
    ...

class LineSegment2f:
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (LineSegment2f)arg1, (V2f)arg2) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> closestPointTo(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue},Imath_3_1::Vec2<float>)'''
    ...
    def dimensions (self, *args, **kwargs):
      '''
dimensions() -> int :

    C++ signature :
        unsigned int dimensions()'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LineSegment2f)arg1) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> direction(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def distance2To (self, *args, **kwargs):
      '''
distance2To( (LineSegment2f)arg1, (V2f)arg2) -> float :

    C++ signature :
        float distance2To(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue},Imath_3_1::Vec2<float>)'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (LineSegment2f)arg1, (V2f)arg2) -> float :

    C++ signature :
        float distanceTo(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue},Imath_3_1::Vec2<float>)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (LineSegment2f)arg1) -> float :

    C++ signature :
        float length(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def length2 (self, *args, **kwargs):
      '''
length2( (LineSegment2f)arg1) -> float :

    C++ signature :
        float length2(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def normalizedDirection (self, *args, **kwargs):
      '''
normalizedDirection( (LineSegment2f)arg1) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> normalizedDirection(IECore::LineSegment<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def p0 (self, *args, **kwargs):
      '''None'''
    ...
    def p1 (self, *args, **kwargs):
      '''None'''
    ...

def LineSegment3d (*args):
      '''
__init__(_object*, Imath_3_1::Vec3<double>, Imath_3_1::Vec3<double>)
__init__(_object*, IECore::LineSegment<Imath_3_1::Vec3<double> >)
__init__(_object*)

'''      
    ...

class LineSegment3d:
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (LineSegment3d)arg1, (V3d)arg2) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> closestPointTo(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue},Imath_3_1::Vec3<double>)'''
    ...
    def closestPoints (self, *args, **kwargs):
      '''
closestPoints( (LineSegment3d)arg1, (LineSegment3d)arg2) -> tuple :

    C++ signature :
        boost::python::tuple closestPoints(IECore::LineSegment<Imath_3_1::Vec3<double> >,IECore::LineSegment<Imath_3_1::Vec3<double> >)'''
    ...
    def dimensions (self, *args, **kwargs):
      '''
dimensions() -> int :

    C++ signature :
        unsigned int dimensions()'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LineSegment3d)arg1) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> direction(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def distance2To (self, *args, **kwargs):
      '''
distance2To( (LineSegment3d)arg1, (V3d)arg2) -> float :

    C++ signature :
        double distance2To(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue},Imath_3_1::Vec3<double>)

distance2To( (LineSegment3d)arg1, (LineSegment3d)arg2) -> float :

    C++ signature :
        double distance2To(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue},IECore::LineSegment<Imath_3_1::Vec3<double> >)'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (LineSegment3d)arg1, (V3d)arg2) -> float :

    C++ signature :
        double distanceTo(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue},Imath_3_1::Vec3<double>)

distanceTo( (LineSegment3d)arg1, (LineSegment3d)arg2) -> float :

    C++ signature :
        double distanceTo(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue},IECore::LineSegment<Imath_3_1::Vec3<double> >)'''
    ...
    def intersect (self, *args, **kwargs):
      '''
intersect( (LineSegment3d)arg1, (Plane3d)arg2) -> tuple :

    C++ signature :
        boost::python::tuple intersect(IECore::LineSegment<Imath_3_1::Vec3<double> >,Imath_3_1::Plane3<double>)'''
    ...
    def intersectT (self, *args, **kwargs):
      '''
intersectT( (LineSegment3d)arg1, (Plane3d)arg2) -> tuple :

    C++ signature :
        boost::python::tuple intersectT(IECore::LineSegment<Imath_3_1::Vec3<double> >,Imath_3_1::Plane3<double>)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (LineSegment3d)arg1) -> float :

    C++ signature :
        double length(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def length2 (self, *args, **kwargs):
      '''
length2( (LineSegment3d)arg1) -> float :

    C++ signature :
        double length2(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def normalizedDirection (self, *args, **kwargs):
      '''
normalizedDirection( (LineSegment3d)arg1) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> normalizedDirection(IECore::LineSegment<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def p0 (self, *args, **kwargs):
      '''None'''
    ...
    def p1 (self, *args, **kwargs):
      '''None'''
    ...

def LineSegment3dData (*args):
      '''
__init__(boost::python::api::object, IECore::LineSegment<Imath_3_1::Vec3<double> >)
__init__(_object*)

'''      
    ...

class LineSegment3dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (LineSegment3dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (LineSegment3dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (LineSegment3dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (LineSegment3dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def LineSegment3dParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class LineSegment3dParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (LineSegment3dParameter)arg1) -> LineSegment3d :

    C++ signature :
        IECore::LineSegment<Imath_3_1::Vec3<double> > getTypedValue(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (LineSegment3dParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue},IECore::TypeId)

isInstanceOf( (LineSegment3dParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (LineSegment3dParameter)arg1, (LineSegment3d)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue},IECore::LineSegment<Imath_3_1::Vec3<double> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (LineSegment3dParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (LineSegment3dParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (LineSegment3dParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<double> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def LineSegment3f (*args):
      '''
__init__(_object*, Imath_3_1::Vec3<float>, Imath_3_1::Vec3<float>)
__init__(_object*, IECore::LineSegment<Imath_3_1::Vec3<float> >)
__init__(_object*)

'''      
    ...

class LineSegment3f:
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (LineSegment3f)arg1, (V3f)arg2) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> closestPointTo(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue},Imath_3_1::Vec3<float>)'''
    ...
    def closestPoints (self, *args, **kwargs):
      '''
closestPoints( (LineSegment3f)arg1, (LineSegment3f)arg2) -> tuple :

    C++ signature :
        boost::python::tuple closestPoints(IECore::LineSegment<Imath_3_1::Vec3<float> >,IECore::LineSegment<Imath_3_1::Vec3<float> >)'''
    ...
    def dimensions (self, *args, **kwargs):
      '''
dimensions() -> int :

    C++ signature :
        unsigned int dimensions()'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LineSegment3f)arg1) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> direction(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def distance2To (self, *args, **kwargs):
      '''
distance2To( (LineSegment3f)arg1, (V3f)arg2) -> float :

    C++ signature :
        float distance2To(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue},Imath_3_1::Vec3<float>)

distance2To( (LineSegment3f)arg1, (LineSegment3f)arg2) -> float :

    C++ signature :
        float distance2To(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue},IECore::LineSegment<Imath_3_1::Vec3<float> >)'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (LineSegment3f)arg1, (V3f)arg2) -> float :

    C++ signature :
        float distanceTo(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue},Imath_3_1::Vec3<float>)

distanceTo( (LineSegment3f)arg1, (LineSegment3f)arg2) -> float :

    C++ signature :
        float distanceTo(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue},IECore::LineSegment<Imath_3_1::Vec3<float> >)'''
    ...
    def intersect (self, *args, **kwargs):
      '''
intersect( (LineSegment3f)arg1, (Plane3f)arg2) -> tuple :

    C++ signature :
        boost::python::tuple intersect(IECore::LineSegment<Imath_3_1::Vec3<float> >,Imath_3_1::Plane3<float>)'''
    ...
    def intersectT (self, *args, **kwargs):
      '''
intersectT( (LineSegment3f)arg1, (Plane3f)arg2) -> tuple :

    C++ signature :
        boost::python::tuple intersectT(IECore::LineSegment<Imath_3_1::Vec3<float> >,Imath_3_1::Plane3<float>)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (LineSegment3f)arg1) -> float :

    C++ signature :
        float length(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def length2 (self, *args, **kwargs):
      '''
length2( (LineSegment3f)arg1) -> float :

    C++ signature :
        float length2(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def normalizedDirection (self, *args, **kwargs):
      '''
normalizedDirection( (LineSegment3f)arg1) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> normalizedDirection(IECore::LineSegment<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def p0 (self, *args, **kwargs):
      '''None'''
    ...
    def p1 (self, *args, **kwargs):
      '''None'''
    ...

def LineSegment3fData (*args):
      '''
__init__(boost::python::api::object, IECore::LineSegment<Imath_3_1::Vec3<float> >)
__init__(_object*)

'''      
    ...

class LineSegment3fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (LineSegment3fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (LineSegment3fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (LineSegment3fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (LineSegment3fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def LineSegment3fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class LineSegment3fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (LineSegment3fParameter)arg1) -> LineSegment3f :

    C++ signature :
        IECore::LineSegment<Imath_3_1::Vec3<float> > getTypedValue(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (LineSegment3fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (LineSegment3fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (LineSegment3fParameter)arg1, (LineSegment3f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue},IECore::LineSegment<Imath_3_1::Vec3<float> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (LineSegment3fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (LineSegment3fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (LineSegment3fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::LineSegment<Imath_3_1::Vec3<float> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Linear (*args):
      '''

'''      
    ...

def Log (*args):
      '''

'''      
    ...

def Lookupdd (*args):
      '''
__init__(_object*)

'''      
    ...

class Lookupdd:
    def init (self, *args, **kwargs):
      '''
init( (Lookupdd)self, (Splinedd)func [, (float)xMin=0 [, (float)xMax=1 [, (int)numSamples=100]]]) -> None :

    C++ signature :
        void init(IECore::Lookup<double, double> {lvalue},IECore::Spline<double, double> {lvalue} [,double=0 [,double=1 [,unsigned int=100]]])'''
    ...

def LookupfColor3f (*args):
      '''
__init__(_object*)

'''      
    ...

class LookupfColor3f:
    def init (self, *args, **kwargs):
      '''
init( (LookupfColor3f)self, (SplinefColor3f)func [, (float)xMin=0 [, (float)xMax=1 [, (int)numSamples=100]]]) -> None :

    C++ signature :
        void init(IECore::Lookup<float, Imath_3_1::Color3<float> > {lvalue},IECore::Spline<float, Imath_3_1::Color3<float> > {lvalue} [,float=0 [,float=1 [,unsigned int=100]]])'''
    ...

def LookupfColor4f (*args):
      '''
__init__(_object*)

'''      
    ...

class LookupfColor4f:
    def init (self, *args, **kwargs):
      '''
init( (LookupfColor4f)self, (SplinefColor4f)func [, (float)xMin=0 [, (float)xMax=1 [, (int)numSamples=100]]]) -> None :

    C++ signature :
        void init(IECore::Lookup<float, Imath_3_1::Color4<float> > {lvalue},IECore::Spline<float, Imath_3_1::Color4<float> > {lvalue} [,float=0 [,float=1 [,unsigned int=100]]])'''
    ...

def Lookupff (*args):
      '''
__init__(_object*)

'''      
    ...

class Lookupff:
    def init (self, *args, **kwargs):
      '''
init( (Lookupff)self, (Splineff)func [, (float)xMin=0 [, (float)xMax=1 [, (int)numSamples=100]]]) -> None :

    C++ signature :
        void init(IECore::Lookup<float, float> {lvalue},IECore::Spline<float, float> {lvalue} [,float=0 [,float=1 [,unsigned int=100]]])'''
    ...

def LsHeaderOp (*args):
      '''

'''      
    ...

class LsHeaderOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def M33dData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Matrix33<double>)
__init__(_object*)

'''      
    ...

class M33dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M33dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix33<double> > {lvalue},IECore::TypeId)

isInstanceOf( (M33dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix33<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M33dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Matrix33<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M33dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Matrix33<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def M33dVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class M33dVectorData:
    def append (self, *args, **kwargs):
      '''
append( (M33dVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (M33dVectorData)arg1, (M33d)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},Imath_3_1::Matrix33<double>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (M33dVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (M33dVectorData)arg1, (M33d)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},Imath_3_1::Matrix33<double>,long,long)

index( (M33dVectorData)arg1, (M33d)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},Imath_3_1::Matrix33<double>)

index( (M33dVectorData)arg1, (M33d)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},Imath_3_1::Matrix33<double>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (M33dVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M33dVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M33dVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (M33dVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},unsigned long)

resize( (M33dVectorData)arg1, (int)arg2, (M33d)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},unsigned long,Imath_3_1::Matrix33<double>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (M33dVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (M33dVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M33dVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M33dVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def M33dVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class M33dVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (M33dVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M33dVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M33dVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (M33dVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue},std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M33dVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M33dVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (M33dVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def M33fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Matrix33<float>)
__init__(_object*)

'''      
    ...

class M33fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M33fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix33<float> > {lvalue},IECore::TypeId)

isInstanceOf( (M33fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix33<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M33fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Matrix33<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M33fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Matrix33<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def M33fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class M33fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (M33fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (M33fVectorData)arg1, (M33f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},Imath_3_1::Matrix33<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (M33fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (M33fVectorData)arg1, (M33f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},Imath_3_1::Matrix33<float>,long,long)

index( (M33fVectorData)arg1, (M33f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},Imath_3_1::Matrix33<float>)

index( (M33fVectorData)arg1, (M33f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},Imath_3_1::Matrix33<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (M33fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M33fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M33fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (M33fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},unsigned long)

resize( (M33fVectorData)arg1, (int)arg2, (M33f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},unsigned long,Imath_3_1::Matrix33<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (M33fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (M33fVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M33fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M33fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def M33fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class M33fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (M33fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M33fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M33fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (M33fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue},std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M33fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M33fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (M33fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def M44dData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Matrix44<double>)
__init__(_object*)

'''      
    ...

class M44dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix44<double> > {lvalue},IECore::TypeId)

isInstanceOf( (M44dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix44<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Matrix44<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Matrix44<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def M44dParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class M44dParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (M44dParameter)arg1) -> M44d :

    C++ signature :
        Imath_3_1::Matrix44<double> getTypedValue(IECore::TypedParameter<Imath_3_1::Matrix44<double> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44dParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Matrix44<double> > {lvalue},IECore::TypeId)

isInstanceOf( (M44dParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Matrix44<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (M44dParameter)arg1, (M44d)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Matrix44<double> > {lvalue},Imath_3_1::Matrix44<double>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44dParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Matrix44<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44dParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Matrix44<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (M44dParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Matrix44<double> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def M44dVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class M44dVectorData:
    def append (self, *args, **kwargs):
      '''
append( (M44dVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (M44dVectorData)arg1, (M44d)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},Imath_3_1::Matrix44<double>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (M44dVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (M44dVectorData)arg1, (M44d)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},Imath_3_1::Matrix44<double>,long,long)

index( (M44dVectorData)arg1, (M44d)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},Imath_3_1::Matrix44<double>)

index( (M44dVectorData)arg1, (M44d)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},Imath_3_1::Matrix44<double>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (M44dVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44dVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M44dVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (M44dVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},unsigned long)

resize( (M44dVectorData)arg1, (int)arg2, (M44d)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},unsigned long,Imath_3_1::Matrix44<double>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (M44dVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (M44dVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44dVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44dVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def M44dVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class M44dVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (M44dVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44dVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M44dVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (M44dVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue},std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44dVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44dVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (M44dVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def M44fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Matrix44<float>)
__init__(_object*)

'''      
    ...

class M44fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix44<float> > {lvalue},IECore::TypeId)

isInstanceOf( (M44fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Matrix44<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Matrix44<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Matrix44<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def M44fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class M44fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (M44fParameter)arg1) -> M44f :

    C++ signature :
        Imath_3_1::Matrix44<float> getTypedValue(IECore::TypedParameter<Imath_3_1::Matrix44<float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Matrix44<float> > {lvalue},IECore::TypeId)

isInstanceOf( (M44fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Matrix44<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (M44fParameter)arg1, (M44f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Matrix44<float> > {lvalue},Imath_3_1::Matrix44<float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Matrix44<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Matrix44<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (M44fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Matrix44<float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def M44fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class M44fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (M44fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (M44fVectorData)arg1, (M44f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},Imath_3_1::Matrix44<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (M44fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (M44fVectorData)arg1, (M44f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},Imath_3_1::Matrix44<float>,long,long)

index( (M44fVectorData)arg1, (M44f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},Imath_3_1::Matrix44<float>)

index( (M44fVectorData)arg1, (M44f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},Imath_3_1::Matrix44<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (M44fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M44fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (M44fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},unsigned long)

resize( (M44fVectorData)arg1, (int)arg2, (M44f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},unsigned long,Imath_3_1::Matrix44<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (M44fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (M44fVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def M44fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class M44fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (M44fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (M44fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (M44fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (M44fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue},std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (M44fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (M44fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (M44fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def MatrixMultiplyOp (*args):
      '''
__init__(_object*)

'''      
    ...

class MatrixMultiplyOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (MatrixMultiplyOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::MatrixMultiplyOp {lvalue},IECore::TypeId)

isInstanceOf( (MatrixMultiplyOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::MatrixMultiplyOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (MatrixMultiplyOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::MatrixMultiplyOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (MatrixMultiplyOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::MatrixMultiplyOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def MemoryIndexedIO (*args):
      '''
__init__(boost::python::api::object, boost::intrusive_ptr<IECore::TypedData<std::vector<char, std::allocator<char> > > const>, boost::python::list, unsigned int)
__init__(boost::python::api::object, boost::intrusive_ptr<IECore::TypedData<std::vector<char, std::allocator<char> > > const>, unsigned int)

'''      
    ...

class MemoryIndexedIO:
    def Append (self, *args, **kwargs):
      '''None'''
    ...
    def Char (self, *args, **kwargs):
      '''None'''
    ...
    def CharArray (self, *args, **kwargs):
      '''None'''
    ...
    def CreateIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def DataType (self, *args, **kwargs):
      '''None'''
    ...
    def Directory (self, *args, **kwargs):
      '''None'''
    ...
    def Double (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleArray (self, *args, **kwargs):
      '''None'''
    ...
    def Entry (self, *args, **kwargs):
      '''None'''
    ...
    def EntryType (self, *args, **kwargs):
      '''None'''
    ...
    def Exclusive (self, *args, **kwargs):
      '''None'''
    ...
    def File (self, *args, **kwargs):
      '''None'''
    ...
    def Float (self, *args, **kwargs):
      '''None'''
    ...
    def FloatArray (self, *args, **kwargs):
      '''None'''
    ...
    def Half (self, *args, **kwargs):
      '''None'''
    ...
    def HalfArray (self, *args, **kwargs):
      '''None'''
    ...
    def Int (self, *args, **kwargs):
      '''None'''
    ...
    def Int64 (self, *args, **kwargs):
      '''None'''
    ...
    def Int64Array (self, *args, **kwargs):
      '''None'''
    ...
    def IntArray (self, *args, **kwargs):
      '''None'''
    ...
    def InternedStringArray (self, *args, **kwargs):
      '''None'''
    ...
    def Invalid (self, *args, **kwargs):
      '''None'''
    ...
    def Long (self, *args, **kwargs):
      '''None'''
    ...
    def LongArray (self, *args, **kwargs):
      '''None'''
    ...
    def MissingBehaviour (self, *args, **kwargs):
      '''None'''
    ...
    def NullIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def OpenMode (self, *args, **kwargs):
      '''None'''
    ...
    def Read (self, *args, **kwargs):
      '''None'''
    ...
    def Shared (self, *args, **kwargs):
      '''None'''
    ...
    def Short (self, *args, **kwargs):
      '''None'''
    ...
    def ShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def String (self, *args, **kwargs):
      '''None'''
    ...
    def StringArray (self, *args, **kwargs):
      '''None'''
    ...
    def ThrowIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def UChar (self, *args, **kwargs):
      '''None'''
    ...
    def UCharArray (self, *args, **kwargs):
      '''None'''
    ...
    def UInt (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64 (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64Array (self, *args, **kwargs):
      '''None'''
    ...
    def UIntArray (self, *args, **kwargs):
      '''None'''
    ...
    def UShort (self, *args, **kwargs):
      '''None'''
    ...
    def UShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def Write (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def buffer (self, *args, **kwargs):
      '''
buffer( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<char, std::allocator<char> > > > buffer(boost::intrusive_ptr<IECore::MemoryIndexedIO>)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)path, (list)root, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::list,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])

create( (object)path, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])'''
    ...
    def createSubdirectory (self, *args, **kwargs):
      '''
createSubdirectory( (IndexedIO)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> createSubdirectory(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def currentEntryId (self, *args, **kwargs):
      '''
currentEntryId( (object)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > currentEntryId(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def directory (self, *args, **kwargs):
      '''
directory( (object)arg1, (list)path [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> directory(boost::intrusive_ptr<IECore::IndexedIO>,boost::python::list [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def entry (self, *args, **kwargs):
      '''
entry( (IndexedIO)arg1, (InternedString)arg2) -> Entry :

    C++ signature :
        IECore::IndexedIO::Entry entry(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def entryIds (self, *args, **kwargs):
      '''
entryIds( (object)arg1) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>)

entryIds( (object)arg1, (EntryType)arg2) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>,IECore::IndexedIO::EntryType)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (MemoryIndexedIO)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::MemoryIndexedIO {lvalue},IECore::TypeId)

isInstanceOf( (MemoryIndexedIO)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::MemoryIndexedIO {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def metadata (self, *args, **kwargs):
      '''
metadata( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundData> metadata(IECore::IndexedIO {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def openMode (self, *args, **kwargs):
      '''
openMode( (IndexedIO)arg1) -> int :

    C++ signature :
        unsigned int openMode(IECore::IndexedIO {lvalue})'''
    ...
    def parentDirectory (self, *args, **kwargs):
      '''
parentDirectory( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> parentDirectory(IECore::IndexedIO {lvalue})'''
    ...
    def path (self, *args, **kwargs):
      '''
path( (object)arg1) -> list :

    C++ signature :
        boost::python::list path(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (object)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::python::api::object read(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def remove (self, *args, **kwargs):
      '''
remove( (IndexedIO)arg1, (InternedString)arg2) -> None :

    C++ signature :
        void remove(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def removeAll (self, *args, **kwargs):
      '''
removeAll( (IndexedIO)arg1) -> None :

    C++ signature :
        void removeAll(IECore::IndexedIO {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def subdirectory (self, *args, **kwargs):
      '''
subdirectory( (IndexedIO)arg1, (InternedString)name [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> subdirectory(IECore::IndexedIO {lvalue},IECore::InternedString [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (MemoryIndexedIO)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::MemoryIndexedIO {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (MemoryIndexedIO)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::MemoryIndexedIO {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def write (self, *args, **kwargs):
      '''
write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > >)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,float)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,double)

write( (IndexedIO)arg1, (InternedString)arg2, (int)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,int)

write( (IndexedIO)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def MenuDefinition (*args):
      '''

'''      
    ...

class MenuDefinition:
    def _MenuDefinition__pathIndex (self, path):
      '''None'''
    ...
    def append (self, path, item):
      '''None'''
    ...
    def clear (self):
      '''None'''
    ...
    def insertAfter (self, path, item, afterPath):
      '''None'''
    ...
    def insertBefore (self, path, item, beforePath):
      '''None'''
    ...
    def item (self, searchPath):
      '''None'''
    ...
    def items (self):
      '''None'''
    ...
    def prepend (self, path, item):
      '''None'''
    ...
    def reRooted (self, root):
      '''None'''
    ...
    def remove (self, path, raiseIfMissing=True):
      '''None'''
    ...
    def removeMatching (self, regEx):
      '''None'''
    ...
    def size (self):
      '''None'''
    ...
    def update (self, definition):
      '''None'''
    ...

def MenuItemDefinition (*args):
      '''

'''      
    ...

class MenuItemDefinition:

def MessageHandler (*args):
      '''
__init__(_object*)

'''      
    ...

class MessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def MessageHandlerOverwriting (*args):
      '''

'''      
    ...

def ModifyOp (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, boost::intrusive_ptr<IECore::Parameter>, boost::intrusive_ptr<IECore::Parameter>)

'''      
    ...

class ModifyOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ModifyOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ModifyOp {lvalue},IECore::TypeId)

isInstanceOf( (ModifyOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ModifyOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ModifyOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ModifyOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ModifyOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ModifyOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def Msg (*args):
      '''
__init__(_object*)

'''      
    ...

class Msg:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def MurmurHash (*args):
      '''
__init__(_object*, unsigned long, unsigned long)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(_object*, IECore::MurmurHash)
__init__(_object*)
__init__(_object*)

'''      
    ...

class MurmurHash:
    def append (self, *args, **kwargs):
      '''
append( (MurmurHash)arg1, (float)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},float)

append( (MurmurHash)arg1, (float)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},double)

append( (MurmurHash)arg1, (int)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},long)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

append( (MurmurHash)arg1, (InternedString)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},IECore::InternedString)

append( (MurmurHash)arg1, (V2i)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Vec2<int>)

append( (MurmurHash)arg1, (V2f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Vec2<float>)

append( (MurmurHash)arg1, (V2d)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Vec2<double>)

append( (MurmurHash)arg1, (V3i)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Vec3<int>)

append( (MurmurHash)arg1, (V3f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Vec3<float>)

append( (MurmurHash)arg1, (V3d)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Vec3<double>)

append( (MurmurHash)arg1, (Color3f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Color3<float>)

append( (MurmurHash)arg1, (Color4f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Color4<float>)

append( (MurmurHash)arg1, (M33f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Matrix33<float>)

append( (MurmurHash)arg1, (M33d)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Matrix33<double>)

append( (MurmurHash)arg1, (M44f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Matrix44<float>)

append( (MurmurHash)arg1, (M44d)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Matrix44<double>)

append( (MurmurHash)arg1, (Box2i)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<int> >)

append( (MurmurHash)arg1, (Box2f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >)

append( (MurmurHash)arg1, (Box2d)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >)

append( (MurmurHash)arg1, (Box3i)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<int> >)

append( (MurmurHash)arg1, (Box3f)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >)

append( (MurmurHash)arg1, (Box3d)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >)

append( (MurmurHash)arg1, (Quatf)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Quat<float>)

append( (MurmurHash)arg1, (Quatd)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},Imath_3_1::Quat<double>)

append( (MurmurHash)arg1, (MurmurHash)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},IECore::MurmurHash)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<char, std::allocator<char> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<short, std::allocator<short> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<long, std::allocator<long> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::half, std::allocator<Imath_3_1::half> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Color3<float>, std::allocator<Imath_3_1::Color3<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Color4<float>, std::allocator<Imath_3_1::Color4<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Matrix33<float>, std::allocator<Imath_3_1::Matrix33<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Matrix33<double>, std::allocator<Imath_3_1::Matrix33<double> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Matrix44<float>, std::allocator<Imath_3_1::Matrix44<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Matrix44<double>, std::allocator<Imath_3_1::Matrix44<double> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<int> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<float> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec2<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec2<double> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<int> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<int> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<float> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<float> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Box<Imath_3_1::Vec3<double> >, std::allocator<Imath_3_1::Box<Imath_3_1::Vec3<double> > > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > const>)

append( (MurmurHash)arg1, (object)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} append(IECore::MurmurHash {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<bool, std::allocator<bool> > > const>)'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (MurmurHash)arg1, (MurmurHash)arg2) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash {lvalue} copyFrom(IECore::MurmurHash {lvalue},IECore::MurmurHash)'''
    ...
    def fromString (self, *args, **kwargs):
      '''
fromString( (object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash fromString(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def h1 (self, *args, **kwargs):
      '''
h1( (MurmurHash)arg1) -> int :

    C++ signature :
        unsigned long h1(IECore::MurmurHash {lvalue})'''
    ...
    def h2 (self, *args, **kwargs):
      '''
h2( (MurmurHash)arg1) -> int :

    C++ signature :
        unsigned long h2(IECore::MurmurHash {lvalue})'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (MurmurHash)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > toString(IECore::MurmurHash {lvalue})'''
    ...

def NullMessageHandler (*args):
      '''
__init__(_object*)

'''      
    ...

class NullMessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def NullObject (*args):
      '''
__init__(_object*)

'''      
    ...

class NullObject:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def defaultNullObject (self, *args, **kwargs):
      '''
defaultNullObject() -> object :

    C++ signature :
        IECore::NullObject* defaultNullObject()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (NullObject)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NullObject {lvalue},IECore::TypeId)

isInstanceOf( (NullObject)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::NullObject {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (NullObject)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::NullObject {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (NullObject)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::NullObject {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def OStreamMessageHandler (*args):
      '''

'''      
    ...

class OStreamMessageHandler:
    def Level (self, *args, **kwargs):
      '''None'''
    ...
    def _Scope (self, *args, **kwargs):
      '''None'''
    ...
    def cErrHandler (self, *args, **kwargs):
      '''
cErrHandler() -> object :

    C++ signature :
        IECore::OStreamMessageHandler* cErrHandler()'''
    ...
    def cOutHandler (self, *args, **kwargs):
      '''
cOutHandler() -> object :

    C++ signature :
        IECore::OStreamMessageHandler* cOutHandler()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def currentHandler (self, *args, **kwargs):
      '''
currentHandler() -> object :

    C++ signature :
        IECore::MessageHandler* currentHandler()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getDefaultHandler (self, *args, **kwargs):
      '''
getDefaultHandler() -> object :

    C++ signature :
        IECore::MessageHandler* getDefaultHandler()'''
    ...
    def handle (self, *args, **kwargs):
      '''
handle( (MessageHandler)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECore::MessageHandler {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

handle( (object)arg1, (Level)arg2, (object)arg3, (object)arg4) -> None :

    C++ signature :
        void handle(IECorePython::Detail::GILReleasePtr<(anonymous namespace)::MessageHandlerWrapper> {lvalue},IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def levelAsString (self, *args, **kwargs):
      '''
levelAsString( (Level)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > levelAsString(IECore::MessageHandler::Level)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def output (self, *args, **kwargs):
      '''
output( (Level)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void output(IECore::MessageHandler::Level,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def setDefaultHandler (self, *args, **kwargs):
      '''
setDefaultHandler( (object)arg1) -> None :

    C++ signature :
        void setDefaultHandler(boost::intrusive_ptr<IECore::MessageHandler>)'''
    ...
    def stringAsLevel (self, *args, **kwargs):
      '''
stringAsLevel( (object)arg1) -> Level :

    C++ signature :
        IECore::MessageHandler::Level stringAsLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def Object (*args):
      '''

'''      
    ...

class Object:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Object)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Object {lvalue},IECore::TypeId)

isInstanceOf( (Object)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Object {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Object)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Object {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Object)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Object {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def ObjectOverwriting (*args):
      '''

'''      
    ...

def ObjectParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::list types)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::list types, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::list types, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::list types, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, IECore::TypeId type)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, IECore::TypeId type, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, IECore::TypeId type, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, IECore::TypeId type, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class ObjectParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ObjectParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectParameter {lvalue},IECore::TypeId)

isInstanceOf( (ObjectParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ObjectParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ObjectParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ObjectParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ObjectParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validTypes (self, *args, **kwargs):
      '''
validTypes( (ObjectParameter)arg1) -> list :

    C++ signature :
        boost::python::list validTypes(IECore::ObjectParameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (ObjectParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::ObjectParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def ObjectPool (*args):
      '''
__init__(_object*, unsigned long)

'''      
    ...

class ObjectPool:
    def StoreCopy (self, *args, **kwargs):
      '''None'''
    ...
    def StoreMode (self, *args, **kwargs):
      '''None'''
    ...
    def StoreReference (self, *args, **kwargs):
      '''None'''
    ...
    def clear (self, *args, **kwargs):
      '''
clear( (ObjectPool)arg1) -> None :

    C++ signature :
        void clear(IECore::ObjectPool {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def contains (self, *args, **kwargs):
      '''
contains( (ObjectPool)arg1, (MurmurHash)arg2) -> bool :

    C++ signature :
        bool contains(IECore::ObjectPool {lvalue},IECore::MurmurHash)'''
    ...
    def defaultObjectPool (self, *args, **kwargs):
      '''
defaultObjectPool() -> object :

    C++ signature :
        IECore::ObjectPool* defaultObjectPool()'''
    ...
    def erase (self, *args, **kwargs):
      '''
erase( (ObjectPool)arg1, (MurmurHash)arg2) -> bool :

    C++ signature :
        bool erase(IECore::ObjectPool {lvalue},IECore::MurmurHash)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getMaxMemoryUsage (self, *args, **kwargs):
      '''
getMaxMemoryUsage( (ObjectPool)arg1) -> int :

    C++ signature :
        unsigned long getMaxMemoryUsage(IECore::ObjectPool {lvalue})'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (ObjectPool)arg1) -> int :

    C++ signature :
        unsigned long memoryUsage(IECore::ObjectPool {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def retrieve (self, *args, **kwargs):
      '''
retrieve( (ObjectPool)arg1, (MurmurHash)key [, (bool)_copy=True]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> retrieve(IECore::ObjectPool,IECore::MurmurHash [,bool=True])'''
    ...
    def setMaxMemoryUsage (self, *args, **kwargs):
      '''
setMaxMemoryUsage( (ObjectPool)arg1, (int)arg2) -> None :

    C++ signature :
        void setMaxMemoryUsage(IECore::ObjectPool {lvalue},unsigned long)'''
    ...
    def store (self, *args, **kwargs):
      '''
store( (ObjectPool)arg1, (Object)arg2, (StoreMode)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> store(IECore::ObjectPool {lvalue},IECore::Object*,IECore::ObjectPool::StoreMode)'''
    ...

def ObjectReader (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(_object*)

'''      
    ...

class ObjectReader:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def canRead (self, *args, **kwargs):
      '''
canRead( (object)arg1) -> bool :

    C++ signature :
        bool canRead(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Reader> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ObjectReader)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectReader {lvalue},IECore::TypeId)

isInstanceOf( (ObjectReader)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectReader {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (ObjectReader)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> read(IECore::ObjectReader {lvalue})'''
    ...
    def readHeader (self, *args, **kwargs):
      '''
readHeader( (ObjectReader)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> readHeader(IECore::ObjectReader {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerReader (self, *args, **kwargs):
      '''
registerReader( (object)arg1, (object)arg2, (object)arg3, (TypeId)arg4) -> None :

    C++ signature :
        void registerReader(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::api::object {lvalue},boost::python::api::object {lvalue},IECore::TypeId)'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()

supportedExtensions( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list supportedExtensions(IECore::TypeId)'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ObjectReader)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ObjectReader {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ObjectReader)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ObjectReader {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def ObjectVector (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(_object*)

'''      
    ...

class ObjectVector:
    def append (self, *args, **kwargs):
      '''
append( (ObjectVector)arg1, (object)arg2) -> None :

    C++ signature :
        void append(IECore::ObjectVector {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (ObjectVector)arg1, (object)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::ObjectVector {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ObjectVector)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectVector {lvalue},IECore::TypeId)

isInstanceOf( (ObjectVector)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectVector {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def remove (self, *args, **kwargs):
      '''
remove( (ObjectVector)arg1, (object)arg2) -> None :

    C++ signature :
        void remove(IECore::ObjectVector {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ObjectVector)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ObjectVector {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ObjectVector)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ObjectVector {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def ObjectVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::ObjectVector> defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::ObjectVector> defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::ObjectVector> defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::ObjectVector> defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class ObjectVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ObjectVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedObjectParameter<IECore::ObjectVector> {lvalue},IECore::TypeId)

isInstanceOf( (ObjectVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedObjectParameter<IECore::ObjectVector> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ObjectVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedObjectParameter<IECore::ObjectVector> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ObjectVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedObjectParameter<IECore::ObjectVector> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validTypes (self, *args, **kwargs):
      '''
validTypes( (ObjectParameter)arg1) -> list :

    C++ signature :
        boost::python::list validTypes(IECore::ObjectParameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (ObjectVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedObjectParameter<IECore::ObjectVector>,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def ObjectWriter (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::Object>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(_object*)

'''      
    ...

class ObjectWriter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def canWrite (self, *args, **kwargs):
      '''
canWrite( (object)arg1, (object)arg2) -> bool :

    C++ signature :
        bool canWrite(boost::intrusive_ptr<IECore::Object const>,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Writer> create(boost::intrusive_ptr<IECore::Object>,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Writer> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ObjectWriter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectWriter {lvalue},IECore::TypeId)

isInstanceOf( (ObjectWriter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ObjectWriter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()

supportedExtensions( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list supportedExtensions(IECore::TypeId)'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ObjectWriter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ObjectWriter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ObjectWriter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ObjectWriter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...
    def write (self, *args, **kwargs):
      '''
write( (Writer)arg1) -> None :

    C++ signature :
        void write(IECore::Writer {lvalue})'''
    ...

def Op (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::CompoundParameter> compoundParameter, boost::intrusive_ptr<IECore::Parameter> resultParameter)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Parameter> resultParameter)

'''      
    ...

class Op:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Op)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Op {lvalue},IECore::TypeId)

isInstanceOf( (Op)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Op {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Op)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Op {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Op)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Op {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def OpOverwriting (*args):
      '''

'''      
    ...

def OptionalCompoundParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='')
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[])
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[], boost::intrusive_ptr<IECore::CompoundObject> userData=None)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description='', boost::python::list members=[], boost::intrusive_ptr<IECore::CompoundObject> userData=None, bool adoptChildPresets=True)

'''      
    ...

class OptionalCompoundParameter:
    def addParameter (self, *args, **kwargs):
      '''
addParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void addParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)'''
    ...
    def addParameters (self, *args, **kwargs):
      '''
addParameters( (CompoundParameter)arg1, (list)arg2) -> None :

    C++ signature :
        void addParameters(IECore::CompoundParameter {lvalue},boost::python::list)'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def clearParameters (self, *args, **kwargs):
      '''
clearParameters( (CompoundParameter)arg1) -> None :

    C++ signature :
        void clearParameters(IECore::CompoundParameter {lvalue})'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getObligatoryParameterNames (self):
      '''None'''
    ...
    def getParameterUndefined (self, paramName):
      '''None'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def has_key (self, *args, **kwargs):
      '''
has_key( (CompoundParameter)arg1, (object)arg2) -> bool :

    C++ signature :
        bool has_key(IECore::CompoundParameter,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def insertParameter (self, *args, **kwargs):
      '''
insertParameter( (CompoundParameter)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void insertParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>,boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list items(IECore::CompoundParameter)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list keys(IECore::CompoundParameter)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameter (self, *args, **kwargs):
      '''
parameter( (CompoundParameter)arg1, (str)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> parameter(IECore::CompoundParameter {lvalue},char const*)'''
    ...
    def parameterPath (self, *args, **kwargs):
      '''
parameterPath( (CompoundParameter)arg1, (object)arg2) -> list :

    C++ signature :
        boost::python::list parameterPath(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter const>)'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def removeParameter (self, *args, **kwargs):
      '''
removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},boost::intrusive_ptr<IECore::Parameter>)

removeParameter( (CompoundParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void removeParameter(IECore::CompoundParameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setObligatoryParameterNames (self, obligatoryParameterNames=None):
      '''None'''
    ...
    def setParameterUndefined (self, paramName):
      '''None'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for CompoundParameter objects. Uses introspection on the given value to define
	how the value will be assigned to the CompoundParameter object.
	'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, value):
      '''None'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (CompoundParameter)arg1) -> list :

    C++ signature :
        boost::python::list values(IECore::CompoundParameter)'''
    ...

def OversamplesCalculator (*args):
      '''
__init__(_object*)
__init__(_object*, float frameRate=24.0)
__init__(_object*, float frameRate=24.0, unsigned int samplesPerFrame=1)
__init__(_object*, float frameRate=24.0, unsigned int samplesPerFrame=1, unsigned int ticksPerSecond=6000)

'''      
    ...

class OversamplesCalculator:
    def framesToTicks (self, *args, **kwargs):
      '''
framesToTicks( (OversamplesCalculator)arg1, (float)arg2) -> int :

    C++ signature :
        int framesToTicks(IECore::OversamplesCalculator {lvalue},float)'''
    ...
    def getFrameRate (self, *args, **kwargs):
      '''
getFrameRate( (OversamplesCalculator)arg1) -> float :

    C++ signature :
        float getFrameRate(IECore::OversamplesCalculator {lvalue})'''
    ...
    def getSamplesPerFrame (self, *args, **kwargs):
      '''
getSamplesPerFrame( (OversamplesCalculator)arg1) -> int :

    C++ signature :
        unsigned int getSamplesPerFrame(IECore::OversamplesCalculator {lvalue})'''
    ...
    def getTicksPerSecond (self, *args, **kwargs):
      '''
getTicksPerSecond( (OversamplesCalculator)arg1) -> int :

    C++ signature :
        unsigned int getTicksPerSecond(IECore::OversamplesCalculator {lvalue})'''
    ...
    def nearestTick (self, *args, **kwargs):
      '''
nearestTick( (OversamplesCalculator)arg1, (int)arg2) -> int :

    C++ signature :
        int nearestTick(IECore::OversamplesCalculator {lvalue},int)'''
    ...
    def setFrameRate (self, *args, **kwargs):
      '''
setFrameRate( (OversamplesCalculator)arg1, (float)arg2) -> None :

    C++ signature :
        void setFrameRate(IECore::OversamplesCalculator {lvalue},float)'''
    ...
    def setSamplesPerFrame (self, *args, **kwargs):
      '''
setSamplesPerFrame( (OversamplesCalculator)arg1, (int)arg2) -> None :

    C++ signature :
        void setSamplesPerFrame(IECore::OversamplesCalculator {lvalue},unsigned int)'''
    ...
    def setTicksPerSecond (self, *args, **kwargs):
      '''
setTicksPerSecond( (OversamplesCalculator)arg1, (int)arg2) -> None :

    C++ signature :
        void setTicksPerSecond(IECore::OversamplesCalculator {lvalue},unsigned int)'''
    ...
    def tickInterval (self, *args, **kwargs):
      '''
tickInterval( (OversamplesCalculator)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple tickInterval(IECore::OversamplesCalculator,float)'''
    ...
    def ticksToFrames (self, *args, **kwargs):
      '''
ticksToFrames( (OversamplesCalculator)arg1, (int)arg2) -> float :

    C++ signature :
        float ticksToFrames(IECore::OversamplesCalculator {lvalue},int)'''
    ...

def Parameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::Object> defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class Parameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Parameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Parameter {lvalue},IECore::TypeId)

isInstanceOf( (Parameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Parameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Parameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Parameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Parameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Parameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (Parameter)arg1 [, (object)arg2]) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter [,boost::intrusive_ptr<IECore::Object const>])'''
    ...

def ParameterAlgo (*args):
      '''

'''      
    ...

def ParameterOverwriting (*args):
      '''

'''      
    ...

def ParameterParser (*args):
      '''

'''      
    ...

class ParameterParser:
    def _ParameterParser__serialiseWalk (self, parameter, value, rootName):
      '''None'''
    ...
    def _ParameterParser__typesToParsers (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def _ParameterParser__typesToSerialisers (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def parse (self, args, parameters):
      '''None'''
    ...
    def registerType (typeId, parser, serialiser):
      '''None'''
    ...
    def registerTypeWithRepr (typeId):
      '''None'''
    ...
    def serialise (self, parameters, values=None):
      '''None'''
    ...

def Parameterised (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::CompoundParameter> compoundParameter)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)

'''      
    ...

class Parameterised:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Parameterised)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Parameterised {lvalue},IECore::TypeId)

isInstanceOf( (Parameterised)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Parameterised {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Parameterised)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Parameterised {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Parameterised)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Parameterised {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def ParameterisedOverwriting (*args):
      '''

'''      
    ...

def PathMatcher (*args):
      '''
__init__(_object*, IECore::PathMatcher)
__init__(boost::python::api::object, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const>)
__init__(boost::python::api::object, boost::python::api::object)
__init__(_object*)

'''      
    ...

class PathMatcher:
    def Result (self, *args, **kwargs):
      '''None'''
    ...
    def addPath (self, *args, **kwargs):
      '''
addPath( (PathMatcher)arg1, (object)arg2) -> bool :

    C++ signature :
        bool addPath(IECore::PathMatcher {lvalue},std::vector<IECore::InternedString, std::allocator<IECore::InternedString> >)

addPath( (PathMatcher)arg1, (object)arg2) -> bool :

    C++ signature :
        bool addPath(IECore::PathMatcher {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def addPaths (self, *args, **kwargs):
      '''
addPaths( (PathMatcher)arg1, (PathMatcher)arg2) -> bool :

    C++ signature :
        bool addPaths(IECore::PathMatcher {lvalue},IECore::PathMatcher)

addPaths( (PathMatcher)arg1, (PathMatcher)arg2, (object)arg3) -> bool :

    C++ signature :
        bool addPaths(IECore::PathMatcher {lvalue},IECore::PathMatcher,std::vector<IECore::InternedString, std::allocator<IECore::InternedString> >)'''
    ...
    def clear (self, *args, **kwargs):
      '''
clear( (PathMatcher)arg1) -> None :

    C++ signature :
        void clear(IECore::PathMatcher {lvalue})'''
    ...
    def init (self, *args, **kwargs):
      '''
init( (PathMatcher)arg1, (object)arg2) -> None :

    C++ signature :
        void init(IECore::PathMatcher {lvalue},boost::python::api::object)'''
    ...
    def intersection (self, *args, **kwargs):
      '''
intersection( (PathMatcher)arg1, (PathMatcher)arg2) -> PathMatcher :

    C++ signature :
        IECore::PathMatcher intersection(IECore::PathMatcher {lvalue},IECore::PathMatcher)'''
    ...
    def isEmpty (self, *args, **kwargs):
      '''
isEmpty( (PathMatcher)arg1) -> bool :

    C++ signature :
        bool isEmpty(IECore::PathMatcher {lvalue})'''
    ...
    def match (self, *args, **kwargs):
      '''
match( (PathMatcher)arg1, (object)arg2) -> int :

    C++ signature :
        unsigned int match(IECore::PathMatcher {lvalue},std::vector<IECore::InternedString, std::allocator<IECore::InternedString> >)

match( (PathMatcher)arg1, (object)arg2) -> int :

    C++ signature :
        unsigned int match(IECore::PathMatcher {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def paths (self, *args, **kwargs):
      '''
paths( (PathMatcher)arg1) -> list :

    C++ signature :
        boost::python::list paths(IECore::PathMatcher)'''
    ...
    def prune (self, *args, **kwargs):
      '''
prune( (PathMatcher)arg1, (object)arg2) -> bool :

    C++ signature :
        bool prune(IECore::PathMatcher {lvalue},std::vector<IECore::InternedString, std::allocator<IECore::InternedString> >)

prune( (PathMatcher)arg1, (object)arg2) -> bool :

    C++ signature :
        bool prune(IECore::PathMatcher {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def removePath (self, *args, **kwargs):
      '''
removePath( (PathMatcher)arg1, (object)arg2) -> bool :

    C++ signature :
        bool removePath(IECore::PathMatcher {lvalue},std::vector<IECore::InternedString, std::allocator<IECore::InternedString> >)

removePath( (PathMatcher)arg1, (object)arg2) -> bool :

    C++ signature :
        bool removePath(IECore::PathMatcher {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def removePaths (self, *args, **kwargs):
      '''
removePaths( (PathMatcher)arg1, (PathMatcher)arg2) -> bool :

    C++ signature :
        bool removePaths(IECore::PathMatcher {lvalue},IECore::PathMatcher)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (PathMatcher)arg1) -> int :

    C++ signature :
        unsigned long size(IECore::PathMatcher {lvalue})'''
    ...
    def subTree (self, *args, **kwargs):
      '''
subTree( (PathMatcher)arg1, (object)arg2) -> PathMatcher :

    C++ signature :
        IECore::PathMatcher subTree(IECore::PathMatcher {lvalue},std::vector<IECore::InternedString, std::allocator<IECore::InternedString> >)

subTree( (PathMatcher)arg1, (object)arg2) -> PathMatcher :

    C++ signature :
        IECore::PathMatcher subTree(IECore::PathMatcher {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def PathMatcherData (*args):
      '''
__init__(_object*, IECore::PathMatcher)
__init__(_object*)

'''      
    ...

class PathMatcherData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (PathMatcherData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::PathMatcher> {lvalue},IECore::TypeId)

isInstanceOf( (PathMatcherData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::PathMatcher> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (PathMatcherData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::PathMatcher> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (PathMatcherData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::PathMatcher> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def PathParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > defaultValue='', bool allowEmptyString=True, IECore::PathParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class PathParameter:
    def CheckType (self, *args, **kwargs):
      '''None'''
    ...
    def allowEmptyString (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (PathParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::PathParameter {lvalue},IECore::TypeId)

isInstanceOf( (PathParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::PathParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mustExist (self, *args, **kwargs):
      '''None'''
    ...
    def mustNotExist (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (PathParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::PathParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (PathParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::PathParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (PathParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::PathParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def PathVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const> defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const> defaultValue, bool allowEmptyList=True)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const> defaultValue, bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const> defaultValue, bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const> defaultValue, bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const> defaultValue, bool allowEmptyList=True, IECore::PathVectorParameter::CheckType check=IECore._IECore.CheckType.DontCare, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class PathVectorParameter:
    def CheckType (self, *args, **kwargs):
      '''None'''
    ...
    def allowEmptyList (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > getTypedValue(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (PathVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::PathVectorParameter {lvalue},IECore::TypeId)

isInstanceOf( (PathVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::PathVectorParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def mustExist (self, *args, **kwargs):
      '''None'''
    ...
    def mustNotExist (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (PathVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::PathVectorParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (PathVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::PathVectorParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (PathVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::PathVectorParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def PointDistribution (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

'''      
    ...

class PointDistribution:
    def defaultInstance (self, *args, **kwargs):
      '''
defaultInstance() -> PointDistribution :

    C++ signature :
        IECore::PointDistribution defaultInstance()'''
    ...

def Preset (*args):
      '''

'''      
    ...

class Preset:
    def applicableTo (self, parameterised, rootParameter):
      '''None'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def metadata (self):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def QuatdData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Quat<double>)
__init__(_object*)

'''      
    ...

class QuatdData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (QuatdData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Quat<double> > {lvalue},IECore::TypeId)

isInstanceOf( (QuatdData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Quat<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (QuatdData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Quat<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (QuatdData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Quat<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def QuatdVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class QuatdVectorData:
    def append (self, *args, **kwargs):
      '''
append( (QuatdVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (QuatdVectorData)arg1, (Quatd)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},Imath_3_1::Quat<double>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (QuatdVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (QuatdVectorData)arg1, (Quatd)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},Imath_3_1::Quat<double>,long,long)

index( (QuatdVectorData)arg1, (Quatd)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},Imath_3_1::Quat<double>)

index( (QuatdVectorData)arg1, (Quatd)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},Imath_3_1::Quat<double>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (QuatdVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (QuatdVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (QuatdVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (QuatdVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},unsigned long)

resize( (QuatdVectorData)arg1, (int)arg2, (Quatd)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},unsigned long,Imath_3_1::Quat<double>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (QuatdVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (QuatdVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (QuatdVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (QuatdVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def QuatdVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class QuatdVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (QuatdVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (QuatdVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (QuatdVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (QuatdVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue},std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (QuatdVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (QuatdVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (QuatdVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Quat<double>, std::allocator<Imath_3_1::Quat<double> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def QuatfData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Quat<float>)
__init__(_object*)

'''      
    ...

class QuatfData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (QuatfData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Quat<float> > {lvalue},IECore::TypeId)

isInstanceOf( (QuatfData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Quat<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (QuatfData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Quat<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (QuatfData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Quat<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def QuatfVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class QuatfVectorData:
    def append (self, *args, **kwargs):
      '''
append( (QuatfVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (QuatfVectorData)arg1, (Quatf)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},Imath_3_1::Quat<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (QuatfVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (QuatfVectorData)arg1, (Quatf)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},Imath_3_1::Quat<float>,long,long)

index( (QuatfVectorData)arg1, (Quatf)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},Imath_3_1::Quat<float>)

index( (QuatfVectorData)arg1, (Quatf)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},Imath_3_1::Quat<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (QuatfVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (QuatfVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (QuatfVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (QuatfVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},unsigned long)

resize( (QuatfVectorData)arg1, (int)arg2, (Quatf)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},unsigned long,Imath_3_1::Quat<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (QuatfVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (QuatfVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (QuatfVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (QuatfVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def QuatfVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class QuatfVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (QuatfVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (QuatfVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (QuatfVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (QuatfVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue},std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (QuatfVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (QuatfVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (QuatfVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Quat<float>, std::allocator<Imath_3_1::Quat<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def RadixSort (*args):
      '''
__init__(_object*)

'''      
    ...

class RadixSort:
    def sort (self, *args, **kwargs):
      '''
sort( (RadixSort)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > > sort(IECorePython::RadixSortWrapper {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > const>)

sort( (RadixSort)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > > sort(IECorePython::RadixSortWrapper {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > const>)

sort( (RadixSort)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > > sort(IECorePython::RadixSortWrapper {lvalue},boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > const>)'''
    ...

def RandomAlgo (*args):
      '''

'''      
    ...

def RandomRotationOp (*args):
      '''
__init__(_object*)

'''      
    ...

class RandomRotationOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (RandomRotationOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::RandomRotationOp {lvalue},IECore::TypeId)

isInstanceOf( (RandomRotationOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::RandomRotationOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (RandomRotationOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::RandomRotationOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (RandomRotationOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::RandomRotationOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def Reader (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description)

'''      
    ...

class Reader:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Reader> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Reader)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Reader {lvalue},IECore::TypeId)

isInstanceOf( (Reader)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Reader {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (Reader)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> read(IECore::Reader {lvalue})'''
    ...
    def readHeader (self, *args, **kwargs):
      '''
readHeader( (Reader)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> readHeader(IECore::Reader {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerReader (self, *args, **kwargs):
      '''
registerReader( (object)arg1, (object)arg2, (object)arg3, (TypeId)arg4) -> None :

    C++ signature :
        void registerReader(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::api::object {lvalue},boost::python::api::object {lvalue},IECore::TypeId)'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()

supportedExtensions( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list supportedExtensions(IECore::TypeId)'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Reader)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Reader {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Reader)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Reader {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def RefCounted (*args):
      '''
__init__(_object*)

'''      
    ...

class RefCounted:
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...

def ReorderedFrameList (*args):
      '''

'''      
    ...

class ReorderedFrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def frameList (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ReorderedFrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ReorderedFrameList {lvalue},IECore::TypeId)

isInstanceOf( (ReorderedFrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ReorderedFrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ReorderedFrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ReorderedFrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ReorderedFrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ReorderedFrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def ReversedFrameList (*args):
      '''
__init__(_object*)
__init__(_object*, boost::intrusive_ptr<IECore::FrameList>)

'''      
    ...

class ReversedFrameList:
    def asClumpedList (self, *args, **kwargs):
      '''
asClumpedList( (object)arg1, (int)arg2) -> list :

    C++ signature :
        boost::python::list asClumpedList(boost::intrusive_ptr<IECore::FrameList>,unsigned int)'''
    ...
    def asList (self, *args, **kwargs):
      '''
asList( (object)arg1) -> list :

    C++ signature :
        boost::python::list asList(boost::intrusive_ptr<IECore::FrameList>)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (FrameList)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> copy(IECore::FrameList {lvalue})'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def frameList (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (FrameList)arg1, (object)arg2) -> bool :

    C++ signature :
        bool isEqualTo(IECore::FrameList {lvalue},boost::intrusive_ptr<IECore::FrameList const>)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ReversedFrameList)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ReversedFrameList {lvalue},IECore::TypeId)

isInstanceOf( (ReversedFrameList)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ReversedFrameList {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parse (self, *args, **kwargs):
      '''
parse( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::FrameList> parse(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ReversedFrameList)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ReversedFrameList {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ReversedFrameList)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ReversedFrameList {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def RunTimeTyped (*args):
      '''

'''      
    ...

class RunTimeTyped:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (RunTimeTyped)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::RunTimeTyped {lvalue},IECore::TypeId)

isInstanceOf( (RunTimeTyped)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::RunTimeTyped {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (RunTimeTyped)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::RunTimeTyped {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (RunTimeTyped)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::RunTimeTyped {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def SearchPath (*args):
      '''
__init__(_object*, IECore::SearchPath)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(boost::python::api::object, boost::python::api::object)
__init__(_object*)

'''      
    ...

class SearchPath:
    def find (self, *args, **kwargs):
      '''
find( (SearchPath)arg1, (str)arg2) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > find(IECore::SearchPath,char const*)'''
    ...
    def getPaths (self, *args, **kwargs):
      '''
getPaths( (SearchPath)arg1, (object)arg2) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getPaths(IECore::SearchPath {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def paths (self, *args, **kwargs):
      '''None'''
    ...
    def setPaths (self, *args, **kwargs):
      '''
setPaths( (SearchPath)arg1, (object)arg2, (object)arg3) -> None :

    C++ signature :
        void setPaths(IECore::SearchPath {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def SearchReplaceOp (*args):
      '''

'''      
    ...

class SearchReplaceOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceCatOp (*args):
      '''

'''      
    ...

class SequenceCatOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceConvertOp (*args):
      '''

'''      
    ...

class SequenceConvertOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceCpOp (*args):
      '''

'''      
    ...

class SequenceCpOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceLsOp (*args):
      '''

'''      
    ...

class SequenceLsOp:
    def _SequenceLsOp__walk (top, topdown=True, followlinks=False):
      '''None'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceMergeOp (*args):
      '''

'''      
    ...

class SequenceMergeOp:
    def _merge (self, fileName1, fileName2, outputFileName):
      '''None'''
    ...
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, args):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceMvOp (*args):
      '''

'''      
    ...

class SequenceMvOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceRenumberOp (*args):
      '''

'''      
    ...

class SequenceRenumberOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def SequenceRmOp (*args):
      '''

'''      
    ...

class SequenceRmOp:
    def baseTypeId ():
      '''None'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName ():
      '''None'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def doOperation (self, operands):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (t):
      '''None'''
    ...
    def isInstanceOf (self, t):
      '''None'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId ():
      '''None'''
    ...
    def staticTypeName ():
      '''None'''
    ...
    def typeId (x):
      '''None'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (x):
      '''None'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def ShortData (*args):
      '''
__init__(boost::python::api::object, short)
__init__(_object*)

'''      
    ...

class ShortData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ShortData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<short> {lvalue},IECore::TypeId)

isInstanceOf( (ShortData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<short> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ShortData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<short> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ShortData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<short> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def ShortVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class ShortVectorData:
    def append (self, *args, **kwargs):
      '''
append( (ShortVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (ShortVectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},short)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (ShortVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (ShortVectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},short,long,long)

index( (ShortVectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},short)

index( (ShortVectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},short,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (ShortVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ShortVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},IECore::TypeId)

isInstanceOf( (ShortVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (ShortVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},unsigned long)

resize( (ShortVectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue},unsigned long,short)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (ShortVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (ShortVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ShortVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ShortVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<short, std::allocator<short> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Splinedd (*args):
      '''
__init__(boost::python::api::object, IECore::CubicBasis<double>, boost::python::api::object)
__init__(_object*, IECore::CubicBasis<double>)
__init__(_object*)

'''      
    ...

class Splinedd:
    def basis (self, *args, **kwargs):
      '''None'''
    ...
    def derivative (self, *args, **kwargs):
      '''
derivative( (Splinedd)arg1, (float)arg2) -> float :

    C++ signature :
        double derivative(IECore::Spline<double, double> {lvalue},double)'''
    ...
    def integral (self, *args, **kwargs):
      '''
integral( (Splinedd)arg1) -> float :

    C++ signature :
        double integral(IECore::Spline<double, double> {lvalue})

integral( (Splinedd)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double integral(IECore::Spline<double, double> {lvalue},double,double)'''
    ...
    def interval (self, *args, **kwargs):
      '''
interval( (Splinedd)arg1) -> tuple :

    C++ signature :
        boost::python::tuple interval(IECore::Spline<double, double>)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (Splinedd)arg1) -> tuple :

    C++ signature :
        boost::python::tuple items(IECore::Spline<double, double>)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (Splinedd)arg1) -> tuple :

    C++ signature :
        boost::python::tuple keys(IECore::Spline<double, double>)'''
    ...
    def points (self, *args, **kwargs):
      '''
points( (Splinedd)arg1) -> tuple :
    Read only access to the control points as a tuple of tuples of ( x, y ) pairs.

    C++ signature :
        boost::python::tuple points(IECore::Spline<double, double>)'''
    ...
    def solve (self, *args, **kwargs):
      '''
solve( (Splinedd)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple solve(IECore::Spline<double, double>,double)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (Splinedd)arg1) -> tuple :

    C++ signature :
        boost::python::tuple values(IECore::Spline<double, double>)'''
    ...

def SplineddData (*args):
      '''
__init__(_object*, IECore::Spline<double, double>)
__init__(_object*)

'''      
    ...

class SplineddData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplineddData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<double, double> > {lvalue},IECore::TypeId)

isInstanceOf( (SplineddData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<double, double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplineddData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::Spline<double, double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplineddData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::Spline<double, double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def SplineddParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class SplineddParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (SplineddParameter)arg1) -> Splinedd :

    C++ signature :
        IECore::Spline<double, double> getTypedValue(IECore::TypedParameter<IECore::Spline<double, double> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplineddParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<double, double> > {lvalue},IECore::TypeId)

isInstanceOf( (SplineddParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<double, double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (SplineddParameter)arg1, (Splinedd)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::Spline<double, double> > {lvalue},IECore::Spline<double, double>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplineddParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::Spline<double, double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplineddParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::Spline<double, double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (SplineddParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::Spline<double, double> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def SplinefColor3f (*args):
      '''
__init__(boost::python::api::object, IECore::CubicBasis<float>, boost::python::api::object)
__init__(_object*, IECore::CubicBasis<float>)
__init__(_object*)

'''      
    ...

class SplinefColor3f:
    def basis (self, *args, **kwargs):
      '''None'''
    ...
    def derivative (self, *args, **kwargs):
      '''
derivative( (SplinefColor3f)arg1, (float)arg2) -> Color3f :

    C++ signature :
        Imath_3_1::Color3<float> derivative(IECore::Spline<float, Imath_3_1::Color3<float> > {lvalue},float)'''
    ...
    def integral (self, *args, **kwargs):
      '''
integral( (SplinefColor3f)arg1) -> Color3f :

    C++ signature :
        Imath_3_1::Color3<float> integral(IECore::Spline<float, Imath_3_1::Color3<float> > {lvalue})

integral( (SplinefColor3f)arg1, (float)arg2, (float)arg3) -> Color3f :

    C++ signature :
        Imath_3_1::Color3<float> integral(IECore::Spline<float, Imath_3_1::Color3<float> > {lvalue},float,float)'''
    ...
    def interval (self, *args, **kwargs):
      '''
interval( (SplinefColor3f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple interval(IECore::Spline<float, Imath_3_1::Color3<float> >)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (SplinefColor3f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple items(IECore::Spline<float, Imath_3_1::Color3<float> >)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (SplinefColor3f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple keys(IECore::Spline<float, Imath_3_1::Color3<float> >)'''
    ...
    def points (self, *args, **kwargs):
      '''
points( (SplinefColor3f)arg1) -> tuple :
    Read only access to the control points as a tuple of tuples of ( x, y ) pairs.

    C++ signature :
        boost::python::tuple points(IECore::Spline<float, Imath_3_1::Color3<float> >)'''
    ...
    def solve (self, *args, **kwargs):
      '''
solve( (SplinefColor3f)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple solve(IECore::Spline<float, Imath_3_1::Color3<float> >,float)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (SplinefColor3f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple values(IECore::Spline<float, Imath_3_1::Color3<float> >)'''
    ...

def SplinefColor3fData (*args):
      '''
__init__(_object*, IECore::Spline<float, Imath_3_1::Color3<float> >)
__init__(_object*)

'''      
    ...

class SplinefColor3fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplinefColor3fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (SplinefColor3fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplinefColor3fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplinefColor3fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def SplinefColor3fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class SplinefColor3fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (SplinefColor3fParameter)arg1) -> SplinefColor3f :

    C++ signature :
        IECore::Spline<float, Imath_3_1::Color3<float> > getTypedValue(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplinefColor3fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (SplinefColor3fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (SplinefColor3fParameter)arg1, (SplinefColor3f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue},IECore::Spline<float, Imath_3_1::Color3<float> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplinefColor3fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplinefColor3fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (SplinefColor3fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color3<float> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def SplinefColor4f (*args):
      '''
__init__(boost::python::api::object, IECore::CubicBasis<float>, boost::python::api::object)
__init__(_object*, IECore::CubicBasis<float>)
__init__(_object*)

'''      
    ...

class SplinefColor4f:
    def basis (self, *args, **kwargs):
      '''None'''
    ...
    def derivative (self, *args, **kwargs):
      '''
derivative( (SplinefColor4f)arg1, (float)arg2) -> Color4f :

    C++ signature :
        Imath_3_1::Color4<float> derivative(IECore::Spline<float, Imath_3_1::Color4<float> > {lvalue},float)'''
    ...
    def integral (self, *args, **kwargs):
      '''
integral( (SplinefColor4f)arg1) -> Color4f :

    C++ signature :
        Imath_3_1::Color4<float> integral(IECore::Spline<float, Imath_3_1::Color4<float> > {lvalue})

integral( (SplinefColor4f)arg1, (float)arg2, (float)arg3) -> Color4f :

    C++ signature :
        Imath_3_1::Color4<float> integral(IECore::Spline<float, Imath_3_1::Color4<float> > {lvalue},float,float)'''
    ...
    def interval (self, *args, **kwargs):
      '''
interval( (SplinefColor4f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple interval(IECore::Spline<float, Imath_3_1::Color4<float> >)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (SplinefColor4f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple items(IECore::Spline<float, Imath_3_1::Color4<float> >)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (SplinefColor4f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple keys(IECore::Spline<float, Imath_3_1::Color4<float> >)'''
    ...
    def points (self, *args, **kwargs):
      '''
points( (SplinefColor4f)arg1) -> tuple :
    Read only access to the control points as a tuple of tuples of ( x, y ) pairs.

    C++ signature :
        boost::python::tuple points(IECore::Spline<float, Imath_3_1::Color4<float> >)'''
    ...
    def solve (self, *args, **kwargs):
      '''
solve( (SplinefColor4f)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple solve(IECore::Spline<float, Imath_3_1::Color4<float> >,float)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (SplinefColor4f)arg1) -> tuple :

    C++ signature :
        boost::python::tuple values(IECore::Spline<float, Imath_3_1::Color4<float> >)'''
    ...

def SplinefColor4fData (*args):
      '''
__init__(_object*, IECore::Spline<float, Imath_3_1::Color4<float> >)
__init__(_object*)

'''      
    ...

class SplinefColor4fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplinefColor4fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (SplinefColor4fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplinefColor4fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplinefColor4fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def SplinefColor4fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class SplinefColor4fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (SplinefColor4fParameter)arg1) -> SplinefColor4f :

    C++ signature :
        IECore::Spline<float, Imath_3_1::Color4<float> > getTypedValue(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplinefColor4fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue},IECore::TypeId)

isInstanceOf( (SplinefColor4fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (SplinefColor4fParameter)arg1, (SplinefColor4f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue},IECore::Spline<float, Imath_3_1::Color4<float> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplinefColor4fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplinefColor4fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (SplinefColor4fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::Spline<float, Imath_3_1::Color4<float> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Splineff (*args):
      '''
__init__(boost::python::api::object, IECore::CubicBasis<float>, boost::python::api::object)
__init__(_object*, IECore::CubicBasis<float>)
__init__(_object*)

'''      
    ...

class Splineff:
    def basis (self, *args, **kwargs):
      '''None'''
    ...
    def derivative (self, *args, **kwargs):
      '''
derivative( (Splineff)arg1, (float)arg2) -> float :

    C++ signature :
        float derivative(IECore::Spline<float, float> {lvalue},float)'''
    ...
    def integral (self, *args, **kwargs):
      '''
integral( (Splineff)arg1) -> float :

    C++ signature :
        float integral(IECore::Spline<float, float> {lvalue})

integral( (Splineff)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        float integral(IECore::Spline<float, float> {lvalue},float,float)'''
    ...
    def interval (self, *args, **kwargs):
      '''
interval( (Splineff)arg1) -> tuple :

    C++ signature :
        boost::python::tuple interval(IECore::Spline<float, float>)'''
    ...
    def items (self, *args, **kwargs):
      '''
items( (Splineff)arg1) -> tuple :

    C++ signature :
        boost::python::tuple items(IECore::Spline<float, float>)'''
    ...
    def keys (self, *args, **kwargs):
      '''
keys( (Splineff)arg1) -> tuple :

    C++ signature :
        boost::python::tuple keys(IECore::Spline<float, float>)'''
    ...
    def points (self, *args, **kwargs):
      '''
points( (Splineff)arg1) -> tuple :
    Read only access to the control points as a tuple of tuples of ( x, y ) pairs.

    C++ signature :
        boost::python::tuple points(IECore::Spline<float, float>)'''
    ...
    def solve (self, *args, **kwargs):
      '''
solve( (Splineff)arg1, (float)arg2) -> tuple :

    C++ signature :
        boost::python::tuple solve(IECore::Spline<float, float>,float)'''
    ...
    def values (self, *args, **kwargs):
      '''
values( (Splineff)arg1) -> tuple :

    C++ signature :
        boost::python::tuple values(IECore::Spline<float, float>)'''
    ...

def SplineffData (*args):
      '''
__init__(_object*, IECore::Spline<float, float>)
__init__(_object*)

'''      
    ...

class SplineffData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplineffData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<float, float> > {lvalue},IECore::TypeId)

isInstanceOf( (SplineffData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::Spline<float, float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplineffData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::Spline<float, float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplineffData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::Spline<float, float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def SplineffParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class SplineffParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (SplineffParameter)arg1) -> Splineff :

    C++ signature :
        IECore::Spline<float, float> getTypedValue(IECore::TypedParameter<IECore::Spline<float, float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (SplineffParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<float, float> > {lvalue},IECore::TypeId)

isInstanceOf( (SplineffParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::Spline<float, float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (SplineffParameter)arg1, (Splineff)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::Spline<float, float> > {lvalue},IECore::Spline<float, float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (SplineffParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::Spline<float, float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (SplineffParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::Spline<float, float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (SplineffParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::Spline<float, float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def StandardCubicBasis (*args):
      '''

'''      
    ...

class StandardCubicBasis:
    def BSpline (self, *args, **kwargs):
      '''None'''
    ...
    def Bezier (self, *args, **kwargs):
      '''None'''
    ...
    def CatmullRom (self, *args, **kwargs):
      '''None'''
    ...
    def Constant (self, *args, **kwargs):
      '''None'''
    ...
    def Linear (self, *args, **kwargs):
      '''None'''
    ...
    def Unknown (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

def StandardRadialLensModel (*args):
      '''

'''      
    ...

class StandardRadialLensModel:
    def Distort (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def Undistort (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def bounds (self, *args, **kwargs):
      '''
bounds( (LensModel)arg1, (int)arg2, (Box2i)arg3, (int)arg4, (int)arg5) -> Box2i :

    C++ signature :
        Imath_3_1::Box<Imath_3_1::Vec2<int> > bounds(IECore::LensModel {lvalue},int,Imath_3_1::Box<Imath_3_1::Vec2<int> >,int,int)'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::LensModel> create(boost::intrusive_ptr<IECore::CompoundObject const>)

create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::LensModel> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::LensModel> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def distort (self, *args, **kwargs):
      '''
distort( (LensModel)arg1, (V2d)arg2) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> distort(IECore::LensModel {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (StandardRadialLensModel)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::StandardRadialLensModel {lvalue},IECore::TypeId)

isInstanceOf( (StandardRadialLensModel)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::StandardRadialLensModel {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def lensModels (self, *args, **kwargs):
      '''
lensModels() -> list :

    C++ signature :
        boost::python::list lensModels()'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (StandardRadialLensModel)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::StandardRadialLensModel {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (StandardRadialLensModel)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::StandardRadialLensModel {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def undistort (self, *args, **kwargs):
      '''
undistort( (LensModel)arg1, (V2d)arg2) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> undistort(IECore::LensModel {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (LensModel)arg1) -> None :

    C++ signature :
        void validate(IECore::LensModel {lvalue})'''
    ...

def StreamIndexedIO (*args):
      '''

'''      
    ...

class StreamIndexedIO:
    def Append (self, *args, **kwargs):
      '''None'''
    ...
    def Char (self, *args, **kwargs):
      '''None'''
    ...
    def CharArray (self, *args, **kwargs):
      '''None'''
    ...
    def CreateIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def DataType (self, *args, **kwargs):
      '''None'''
    ...
    def Directory (self, *args, **kwargs):
      '''None'''
    ...
    def Double (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleArray (self, *args, **kwargs):
      '''None'''
    ...
    def Entry (self, *args, **kwargs):
      '''None'''
    ...
    def EntryType (self, *args, **kwargs):
      '''None'''
    ...
    def Exclusive (self, *args, **kwargs):
      '''None'''
    ...
    def File (self, *args, **kwargs):
      '''None'''
    ...
    def Float (self, *args, **kwargs):
      '''None'''
    ...
    def FloatArray (self, *args, **kwargs):
      '''None'''
    ...
    def Half (self, *args, **kwargs):
      '''None'''
    ...
    def HalfArray (self, *args, **kwargs):
      '''None'''
    ...
    def Int (self, *args, **kwargs):
      '''None'''
    ...
    def Int64 (self, *args, **kwargs):
      '''None'''
    ...
    def Int64Array (self, *args, **kwargs):
      '''None'''
    ...
    def IntArray (self, *args, **kwargs):
      '''None'''
    ...
    def InternedStringArray (self, *args, **kwargs):
      '''None'''
    ...
    def Invalid (self, *args, **kwargs):
      '''None'''
    ...
    def Long (self, *args, **kwargs):
      '''None'''
    ...
    def LongArray (self, *args, **kwargs):
      '''None'''
    ...
    def MissingBehaviour (self, *args, **kwargs):
      '''None'''
    ...
    def NullIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def OpenMode (self, *args, **kwargs):
      '''None'''
    ...
    def Read (self, *args, **kwargs):
      '''None'''
    ...
    def Shared (self, *args, **kwargs):
      '''None'''
    ...
    def Short (self, *args, **kwargs):
      '''None'''
    ...
    def ShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def String (self, *args, **kwargs):
      '''None'''
    ...
    def StringArray (self, *args, **kwargs):
      '''None'''
    ...
    def ThrowIfMissing (self, *args, **kwargs):
      '''None'''
    ...
    def UChar (self, *args, **kwargs):
      '''None'''
    ...
    def UCharArray (self, *args, **kwargs):
      '''None'''
    ...
    def UInt (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64 (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64Array (self, *args, **kwargs):
      '''None'''
    ...
    def UIntArray (self, *args, **kwargs):
      '''None'''
    ...
    def UShort (self, *args, **kwargs):
      '''None'''
    ...
    def UShortArray (self, *args, **kwargs):
      '''None'''
    ...
    def Write (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)path, (list)root, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,boost::python::list,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])

create( (object)path, (int)mode [, (object)options=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int [,boost::intrusive_ptr<IECore::CompoundData>=None])'''
    ...
    def createSubdirectory (self, *args, **kwargs):
      '''
createSubdirectory( (IndexedIO)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> createSubdirectory(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def currentEntryId (self, *args, **kwargs):
      '''
currentEntryId( (object)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > currentEntryId(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def directory (self, *args, **kwargs):
      '''
directory( (object)arg1, (list)path [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> directory(boost::intrusive_ptr<IECore::IndexedIO>,boost::python::list [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def entry (self, *args, **kwargs):
      '''
entry( (IndexedIO)arg1, (InternedString)arg2) -> Entry :

    C++ signature :
        IECore::IndexedIO::Entry entry(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def entryIds (self, *args, **kwargs):
      '''
entryIds( (object)arg1) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>)

entryIds( (object)arg1, (EntryType)arg2) -> list :

    C++ signature :
        boost::python::list entryIds(boost::intrusive_ptr<IECore::IndexedIO>,IECore::IndexedIO::EntryType)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (StreamIndexedIO)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::StreamIndexedIO {lvalue},IECore::TypeId)

isInstanceOf( (StreamIndexedIO)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::StreamIndexedIO {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def metadata (self, *args, **kwargs):
      '''
metadata( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundData> metadata(IECore::IndexedIO {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def openMode (self, *args, **kwargs):
      '''
openMode( (IndexedIO)arg1) -> int :

    C++ signature :
        unsigned int openMode(IECore::IndexedIO {lvalue})'''
    ...
    def parentDirectory (self, *args, **kwargs):
      '''
parentDirectory( (IndexedIO)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> parentDirectory(IECore::IndexedIO {lvalue})'''
    ...
    def path (self, *args, **kwargs):
      '''
path( (object)arg1) -> list :

    C++ signature :
        boost::python::list path(boost::intrusive_ptr<IECore::IndexedIO>)'''
    ...
    def read (self, *args, **kwargs):
      '''
read( (object)arg1, (InternedString)arg2) -> object :

    C++ signature :
        boost::python::api::object read(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def remove (self, *args, **kwargs):
      '''
remove( (IndexedIO)arg1, (InternedString)arg2) -> None :

    C++ signature :
        void remove(IECore::IndexedIO {lvalue},IECore::InternedString)'''
    ...
    def removeAll (self, *args, **kwargs):
      '''
removeAll( (IndexedIO)arg1) -> None :

    C++ signature :
        void removeAll(IECore::IndexedIO {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def subdirectory (self, *args, **kwargs):
      '''
subdirectory( (IndexedIO)arg1, (InternedString)name [, (MissingBehaviour)missingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::IndexedIO> subdirectory(IECore::IndexedIO {lvalue},IECore::InternedString [,IECore::IndexedIO::MissingBehaviour=IECore._IECore.MissingBehaviour.ThrowIfMissing])'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (StreamIndexedIO)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::StreamIndexedIO {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (StreamIndexedIO)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::StreamIndexedIO {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def write (self, *args, **kwargs):
      '''
write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<float, std::allocator<float> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<double, std::allocator<double> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >)

write( (object)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString,boost::intrusive_ptr<IECore::TypedData<std::vector<IECore::InternedString, std::allocator<IECore::InternedString> > > >)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,float)

write( (IndexedIO)arg1, (InternedString)arg2, (float)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,double)

write( (IndexedIO)arg1, (InternedString)arg2, (int)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,int)

write( (IndexedIO)arg1, (InternedString)arg2, (object)arg3) -> None :

    C++ signature :
        void write(IECore::IndexedIO {lvalue},IECore::InternedString,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...

def StringAlgo (*args):
      '''

'''      
    ...

def StringData (*args):
      '''
__init__(boost::python::api::object, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)
__init__(_object*)

'''      
    ...

class StringData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (StringData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},IECore::TypeId)

isInstanceOf( (StringData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (StringData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (StringData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def StringParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class StringParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (StringParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},IECore::TypeId)

isInstanceOf( (StringParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (StringParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (StringParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (StringParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def StringUtil (*args):
      '''

'''      
    ...

def StringVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class StringVectorData:
    def append (self, *args, **kwargs):
      '''
append( (StringVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (StringVectorData)arg1, (object)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (StringVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (StringVectorData)arg1, (object)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,long,long)

index( (StringVectorData)arg1, (object)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

index( (StringVectorData)arg1, (object)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (StringVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (StringVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (StringVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (StringVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},unsigned long)

resize( (StringVectorData)arg1, (int)arg2, (object)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},unsigned long,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (StringVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (StringVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (StringVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def StringVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class StringVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > getTypedValue(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (StringVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},IECore::TypeId)

isInstanceOf( (StringVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue},std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (StringVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (StringVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (StringVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def Struct (*args):
      '''

'''      
    ...

class Struct:

def SubstitutedDict (*args):
      '''

'''      
    ...

class SubstitutedDict:
    def get (self, key, defaultValue=None, substituted=True):
      '''None'''
    ...
    def items (self, substituted=True):
      '''None'''
    ...
    def keys (self):
      '''None'''
    ...
    def substitutions (self):
      '''None'''
    ...
    def values (self, substituted=True):
      '''None'''
    ...

def TestUtil (*args):
      '''

'''      
    ...

class TestUtil:
    def inCI ():
      '''None'''
    ...
    def inMacCI ():
      '''None'''
    ...
    def inWindowsCI ():
      '''None'''
    ...
    def platformMac ():
      '''None'''
    ...
    def platformWindows ():
      '''None'''
    ...

def TimeCode (*args):
      '''
__init__(_object*, int hours, int minutes, int seconds, int frame)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0, int binaryGroup3=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0, int binaryGroup3=0, int binaryGroup4=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0, int binaryGroup3=0, int binaryGroup4=0, int binaryGroup5=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0, int binaryGroup3=0, int binaryGroup4=0, int binaryGroup5=0, int binaryGroup6=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0, int binaryGroup3=0, int binaryGroup4=0, int binaryGroup5=0, int binaryGroup6=0, int binaryGroup7=0)
__init__(_object*, int hours, int minutes, int seconds, int frame, bool dropFrame=False, bool colorFrame=False, bool fieldPhase=False, bool bgf0=False, bool bgf1=False, bool bgf2=False, int binaryGroup1=0, int binaryGroup2=0, int binaryGroup3=0, int binaryGroup4=0, int binaryGroup5=0, int binaryGroup6=0, int binaryGroup7=0, int binaryGroup8=0)
__init__(_object*, int timeAndFlags)
__init__(_object*, int timeAndFlags, int userData=0)
__init__(_object*, int timeAndFlags, int userData=0, Imf_3_1::TimeCode::Packing packing)
__init__(_object*, Imf_3_1::TimeCode)
__init__(_object*)
__init__(_object*)

'''      
    ...

class TimeCode:
    def Packing (self, *args, **kwargs):
      '''None'''
    ...
    def bgf0 (self, *args, **kwargs):
      '''
bgf0( (TimeCode)arg1) -> bool :

    C++ signature :
        bool bgf0(Imf_3_1::TimeCode {lvalue})'''
    ...
    def bgf1 (self, *args, **kwargs):
      '''
bgf1( (TimeCode)arg1) -> bool :

    C++ signature :
        bool bgf1(Imf_3_1::TimeCode {lvalue})'''
    ...
    def bgf2 (self, *args, **kwargs):
      '''
bgf2( (TimeCode)arg1) -> bool :

    C++ signature :
        bool bgf2(Imf_3_1::TimeCode {lvalue})'''
    ...
    def binaryGroup (self, *args, **kwargs):
      '''
binaryGroup( (TimeCode)arg1, (int)arg2) -> int :

    C++ signature :
        int binaryGroup(Imf_3_1::TimeCode {lvalue},int)'''
    ...
    def colorFrame (self, *args, **kwargs):
      '''
colorFrame( (TimeCode)arg1) -> bool :

    C++ signature :
        bool colorFrame(Imf_3_1::TimeCode {lvalue})'''
    ...
    def dropFrame (self, *args, **kwargs):
      '''
dropFrame( (TimeCode)arg1) -> bool :

    C++ signature :
        bool dropFrame(Imf_3_1::TimeCode {lvalue})'''
    ...
    def fieldPhase (self, *args, **kwargs):
      '''
fieldPhase( (TimeCode)arg1) -> bool :

    C++ signature :
        bool fieldPhase(Imf_3_1::TimeCode {lvalue})'''
    ...
    def frame (self, *args, **kwargs):
      '''
frame( (TimeCode)arg1) -> int :

    C++ signature :
        int frame(Imf_3_1::TimeCode {lvalue})'''
    ...
    def hours (self, *args, **kwargs):
      '''
hours( (TimeCode)arg1) -> int :

    C++ signature :
        int hours(Imf_3_1::TimeCode {lvalue})'''
    ...
    def minutes (self, *args, **kwargs):
      '''
minutes( (TimeCode)arg1) -> int :

    C++ signature :
        int minutes(Imf_3_1::TimeCode {lvalue})'''
    ...
    def seconds (self, *args, **kwargs):
      '''
seconds( (TimeCode)arg1) -> int :

    C++ signature :
        int seconds(Imf_3_1::TimeCode {lvalue})'''
    ...
    def setBgf0 (self, *args, **kwargs):
      '''
setBgf0( (TimeCode)arg1, (bool)arg2) -> None :

    C++ signature :
        void setBgf0(Imf_3_1::TimeCode {lvalue},bool)'''
    ...
    def setBgf1 (self, *args, **kwargs):
      '''
setBgf1( (TimeCode)arg1, (bool)arg2) -> None :

    C++ signature :
        void setBgf1(Imf_3_1::TimeCode {lvalue},bool)'''
    ...
    def setBgf2 (self, *args, **kwargs):
      '''
setBgf2( (TimeCode)arg1, (bool)arg2) -> None :

    C++ signature :
        void setBgf2(Imf_3_1::TimeCode {lvalue},bool)'''
    ...
    def setBinaryGroup (self, *args, **kwargs):
      '''
setBinaryGroup( (TimeCode)arg1, (int)arg2, (int)arg3) -> None :

    C++ signature :
        void setBinaryGroup(Imf_3_1::TimeCode {lvalue},int,int)'''
    ...
    def setColorFrame (self, *args, **kwargs):
      '''
setColorFrame( (TimeCode)arg1, (bool)arg2) -> None :

    C++ signature :
        void setColorFrame(Imf_3_1::TimeCode {lvalue},bool)'''
    ...
    def setDropFrame (self, *args, **kwargs):
      '''
setDropFrame( (TimeCode)arg1, (bool)arg2) -> None :

    C++ signature :
        void setDropFrame(Imf_3_1::TimeCode {lvalue},bool)'''
    ...
    def setFieldPhase (self, *args, **kwargs):
      '''
setFieldPhase( (TimeCode)arg1, (bool)arg2) -> None :

    C++ signature :
        void setFieldPhase(Imf_3_1::TimeCode {lvalue},bool)'''
    ...
    def setFrame (self, *args, **kwargs):
      '''
setFrame( (TimeCode)arg1, (int)arg2) -> None :

    C++ signature :
        void setFrame(Imf_3_1::TimeCode {lvalue},int)'''
    ...
    def setHours (self, *args, **kwargs):
      '''
setHours( (TimeCode)arg1, (int)arg2) -> None :

    C++ signature :
        void setHours(Imf_3_1::TimeCode {lvalue},int)'''
    ...
    def setMinutes (self, *args, **kwargs):
      '''
setMinutes( (TimeCode)arg1, (int)arg2) -> None :

    C++ signature :
        void setMinutes(Imf_3_1::TimeCode {lvalue},int)'''
    ...
    def setSeconds (self, *args, **kwargs):
      '''
setSeconds( (TimeCode)arg1, (int)arg2) -> None :

    C++ signature :
        void setSeconds(Imf_3_1::TimeCode {lvalue},int)'''
    ...
    def setTimeAndFlags (self, *args, **kwargs):
      '''
setTimeAndFlags( (TimeCode)self, (int)value [, (Packing)packing=IECore._IECore.Packing.TV60]) -> None :

    C++ signature :
        void setTimeAndFlags(Imf_3_1::TimeCode {lvalue},unsigned int [,Imf_3_1::TimeCode::Packing=IECore._IECore.Packing.TV60])'''
    ...
    def setUserData (self, *args, **kwargs):
      '''
setUserData( (TimeCode)arg1, (int)arg2) -> None :

    C++ signature :
        void setUserData(Imf_3_1::TimeCode {lvalue},unsigned int)'''
    ...
    def timeAndFlags (self, *args, **kwargs):
      '''
timeAndFlags( (TimeCode)self [, (Packing)packing=IECore._IECore.Packing.TV60]) -> int :

    C++ signature :
        unsigned int timeAndFlags(Imf_3_1::TimeCode {lvalue} [,Imf_3_1::TimeCode::Packing=IECore._IECore.Packing.TV60])'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (TimeCode)arg1) -> int :

    C++ signature :
        unsigned int userData(Imf_3_1::TimeCode {lvalue})'''
    ...

def TimeCodeData (*args):
      '''
__init__(_object*, Imf_3_1::TimeCode)
__init__(_object*)

'''      
    ...

class TimeCodeData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (TimeCodeData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imf_3_1::TimeCode> {lvalue},IECore::TypeId)

isInstanceOf( (TimeCodeData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imf_3_1::TimeCode> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (TimeCodeData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imf_3_1::TimeCode> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (TimeCodeData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imf_3_1::TimeCode> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''None'''
    ...

def Timer (*args):
      '''
__init__(_object*)
__init__(_object*, bool, IECore::Timer::Mode)
__init__(_object*, bool)

'''      
    ...

class Timer:
    def Mode (self, *args, **kwargs):
      '''None'''
    ...
    def SystemCPU (self, *args, **kwargs):
      '''None'''
    ...
    def UserCPU (self, *args, **kwargs):
      '''None'''
    ...
    def WallClock (self, *args, **kwargs):
      '''None'''
    ...
    def currentElapsed (self, *args, **kwargs):
      '''
currentElapsed( (Timer)arg1) -> float :

    C++ signature :
        double currentElapsed(IECore::Timer {lvalue})'''
    ...
    def running (self, *args, **kwargs):
      '''
running( (Timer)arg1) -> bool :

    C++ signature :
        bool running(IECore::Timer {lvalue})'''
    ...
    def start (self, *args, **kwargs):
      '''
start( (Timer)arg1) -> None :

    C++ signature :
        void start(IECore::Timer {lvalue})'''
    ...
    def stop (self, *args, **kwargs):
      '''
stop( (Timer)arg1) -> float :

    C++ signature :
        double stop(IECore::Timer {lvalue})'''
    ...
    def totalElapsed (self, *args, **kwargs):
      '''
totalElapsed( (Timer)arg1) -> float :

    C++ signature :
        double totalElapsed(IECore::Timer {lvalue})'''
    ...

def ToCoreConverter (*args):
      '''

'''      
    ...

class ToCoreConverter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def convert (self, *args, **kwargs):
      '''
convert( (ToCoreConverter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> convert(IECore::ToCoreConverter const*)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ToCoreConverter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ToCoreConverter {lvalue},IECore::TypeId)

isInstanceOf( (ToCoreConverter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ToCoreConverter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ToCoreConverter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ToCoreConverter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ToCoreConverter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ToCoreConverter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def TransformationMatrixd (*args):
      '''
__init__(_object*, IECore::TransformationMatrix<double>)
__init__(_object*, Imath_3_1::Vec3<double>, Imath_3_1::Euler<double>, Imath_3_1::Vec3<double>)
__init__(_object*)
__init__(_object*)

'''      
    ...

class TransformationMatrixd:
    def rotate (self, *args, **kwargs):
      '''None'''
    ...
    def rotatePivot (self, *args, **kwargs):
      '''None'''
    ...
    def rotatePivotTranslation (self, *args, **kwargs):
      '''None'''
    ...
    def rotationOrientation (self, *args, **kwargs):
      '''None'''
    ...
    def scale (self, *args, **kwargs):
      '''None'''
    ...
    def scalePivot (self, *args, **kwargs):
      '''None'''
    ...
    def scalePivotTranslation (self, *args, **kwargs):
      '''None'''
    ...
    def shear (self, *args, **kwargs):
      '''None'''
    ...
    def transform (self, *args, **kwargs):
      '''None'''
    ...
    def translate (self, *args, **kwargs):
      '''None'''
    ...

def TransformationMatrixdData (*args):
      '''
__init__(boost::python::api::object, IECore::TransformationMatrix<double>)
__init__(boost::python::api::object)

'''      
    ...

class TransformationMatrixdData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (TransformationMatrixdData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::TransformationMatrix<double> > {lvalue},IECore::TypeId)

isInstanceOf( (TransformationMatrixdData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::TransformationMatrix<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (TransformationMatrixdData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::TransformationMatrix<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (TransformationMatrixdData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::TransformationMatrix<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def TransformationMatrixdParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class TransformationMatrixdParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (TransformationMatrixdParameter)arg1) -> TransformationMatrixd :

    C++ signature :
        IECore::TransformationMatrix<double> getTypedValue(IECore::TypedParameter<IECore::TransformationMatrix<double> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (TransformationMatrixdParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::TransformationMatrix<double> > {lvalue},IECore::TypeId)

isInstanceOf( (TransformationMatrixdParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::TransformationMatrix<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (TransformationMatrixdParameter)arg1, (TransformationMatrixd)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::TransformationMatrix<double> > {lvalue},IECore::TransformationMatrix<double>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (TransformationMatrixdParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::TransformationMatrix<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (TransformationMatrixdParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::TransformationMatrix<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (TransformationMatrixdParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::TransformationMatrix<double> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def TransformationMatrixf (*args):
      '''
__init__(_object*, IECore::TransformationMatrix<float>)
__init__(_object*, Imath_3_1::Vec3<float>, Imath_3_1::Euler<float>, Imath_3_1::Vec3<float>)
__init__(_object*)
__init__(_object*)

'''      
    ...

class TransformationMatrixf:
    def rotate (self, *args, **kwargs):
      '''None'''
    ...
    def rotatePivot (self, *args, **kwargs):
      '''None'''
    ...
    def rotatePivotTranslation (self, *args, **kwargs):
      '''None'''
    ...
    def rotationOrientation (self, *args, **kwargs):
      '''None'''
    ...
    def scale (self, *args, **kwargs):
      '''None'''
    ...
    def scalePivot (self, *args, **kwargs):
      '''None'''
    ...
    def scalePivotTranslation (self, *args, **kwargs):
      '''None'''
    ...
    def shear (self, *args, **kwargs):
      '''None'''
    ...
    def transform (self, *args, **kwargs):
      '''None'''
    ...
    def translate (self, *args, **kwargs):
      '''None'''
    ...

def TransformationMatrixfData (*args):
      '''
__init__(boost::python::api::object, IECore::TransformationMatrix<float>)
__init__(boost::python::api::object)

'''      
    ...

class TransformationMatrixfData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (TransformationMatrixfData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::TransformationMatrix<float> > {lvalue},IECore::TypeId)

isInstanceOf( (TransformationMatrixfData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<IECore::TransformationMatrix<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (TransformationMatrixfData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<IECore::TransformationMatrix<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (TransformationMatrixfData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<IECore::TransformationMatrix<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def TransformationMatrixfParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class TransformationMatrixfParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (TransformationMatrixfParameter)arg1) -> TransformationMatrixf :

    C++ signature :
        IECore::TransformationMatrix<float> getTypedValue(IECore::TypedParameter<IECore::TransformationMatrix<float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (TransformationMatrixfParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::TransformationMatrix<float> > {lvalue},IECore::TypeId)

isInstanceOf( (TransformationMatrixfParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<IECore::TransformationMatrix<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (TransformationMatrixfParameter)arg1, (TransformationMatrixf)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<IECore::TransformationMatrix<float> > {lvalue},IECore::TransformationMatrix<float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (TransformationMatrixfParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<IECore::TransformationMatrix<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (TransformationMatrixfParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<IECore::TransformationMatrix<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (TransformationMatrixfParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<IECore::TransformationMatrix<float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def TypeId (*args):
      '''

'''      
    ...

class TypeId:
    def AddTen (self, *args, **kwargs):
      '''None'''
    ...
    def BasicPreset (self, *args, **kwargs):
      '''None'''
    ...
    def BinaryFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def BlindDataHolder (self, *args, **kwargs):
      '''None'''
    ...
    def BoolData (self, *args, **kwargs):
      '''None'''
    ...
    def BoolParameter (self, *args, **kwargs):
      '''None'''
    ...
    def BoolVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def BoolVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box2dData (self, *args, **kwargs):
      '''None'''
    ...
    def Box2dParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box2dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Box2fData (self, *args, **kwargs):
      '''None'''
    ...
    def Box2fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box2fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Box2iData (self, *args, **kwargs):
      '''None'''
    ...
    def Box2iParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box2iVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Box3dData (self, *args, **kwargs):
      '''None'''
    ...
    def Box3dParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box3dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Box3dVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box3fData (self, *args, **kwargs):
      '''None'''
    ...
    def Box3fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box3fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Box3fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box3iData (self, *args, **kwargs):
      '''None'''
    ...
    def Box3iParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Box3iVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def CharData (self, *args, **kwargs):
      '''None'''
    ...
    def CharVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def ClassLsOp (self, *args, **kwargs):
      '''None'''
    ...
    def ClassParameter (self, *args, **kwargs):
      '''None'''
    ...
    def ClassVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Color3dData (self, *args, **kwargs):
      '''None'''
    ...
    def Color3dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Color3fData (self, *args, **kwargs):
      '''None'''
    ...
    def Color3fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Color3fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Color3fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Color4dData (self, *args, **kwargs):
      '''None'''
    ...
    def Color4fData (self, *args, **kwargs):
      '''None'''
    ...
    def Color4fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Color4fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Color4fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundData (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundDataNode (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundObject (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundObjectParameter (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundParameter (self, *args, **kwargs):
      '''None'''
    ...
    def CompoundVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Converter (self, *args, **kwargs):
      '''None'''
    ...
    def CustomSpreadsheet (self, *args, **kwargs):
      '''None'''
    ...
    def Data (self, *args, **kwargs):
      '''None'''
    ...
    def DataCastOp (self, *args, **kwargs):
      '''None'''
    ...
    def DataConvertOp (self, *args, **kwargs):
      '''None'''
    ...
    def DataInterleaveOp (self, *args, **kwargs):
      '''None'''
    ...
    def DataPromoteOp (self, *args, **kwargs):
      '''None'''
    ...
    def DateTimeData (self, *args, **kwargs):
      '''None'''
    ...
    def DateTimeParameter (self, *args, **kwargs):
      '''None'''
    ...
    def DebugDispatcher (self, *args, **kwargs):
      '''None'''
    ...
    def DerivedAddNode (self, *args, **kwargs):
      '''None'''
    ...
    def DirNameParameter (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleData (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleParameter (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def DoubleVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def EmptyFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def ExclusionFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def FileIndexedIO (self, *args, **kwargs):
      '''None'''
    ...
    def FileNameParameter (self, *args, **kwargs):
      '''None'''
    ...
    def FileSequence (self, *args, **kwargs):
      '''None'''
    ...
    def FileSequenceParameter (self, *args, **kwargs):
      '''None'''
    ...
    def FileSequenceVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def FloatData (self, *args, **kwargs):
      '''None'''
    ...
    def FloatParameter (self, *args, **kwargs):
      '''None'''
    ...
    def FloatVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def FloatVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def FrameList (self, *args, **kwargs):
      '''None'''
    ...
    def FrameListParameter (self, *args, **kwargs):
      '''None'''
    ...
    def FrameRange (self, *args, **kwargs):
      '''None'''
    ...
    def FromCoreConverter (self, *args, **kwargs):
      '''None'''
    ...
    def Gaffer::Application (self, *args, **kwargs):
      '''None'''
    ...
    def Gaffer::DictPath (self, *args, **kwargs):
      '''None'''
    ...
    def Gaffer::FileNamePathFilter (self, *args, **kwargs):
      '''None'''
    ...
    def Gaffer::GraphComponentPath (self, *args, **kwargs):
      '''None'''
    ...
    def Gaffer::InfoPathFilter (self, *args, **kwargs):
      '''None'''
    ...
    def Gaffer::SequencePath (self, *args, **kwargs):
      '''None'''
    ...
    def GafferCycles::CyclesShaderBall (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::LocalDispatcher (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::PythonCommand (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::SystemCommand (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::TaskContextProcessor (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::TaskContextVariables (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::TaskSwitch (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatch::Wedge (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatchTest::ErroringTaskNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatchTest::LoggingTaskNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferDispatchTest::TextWriter (self, *args, **kwargs):
      '''None'''
    ...
    def GafferImage::Anaglyph (self, *args, **kwargs):
      '''None'''
    ...
    def GafferImage::BleedFill (self, *args, **kwargs):
      '''None'''
    ...
    def GafferImage::CatalogueSelect (self, *args, **kwargs):
      '''None'''
    ...
    def GafferImage::ContactSheet (self, *args, **kwargs):
      '''None'''
    ...
    def GafferImage::DeepTidy (self, *args, **kwargs):
      '''None'''
    ...
    def GafferImageUI::ImageInspector::Settings (self, *args, **kwargs):
      '''None'''
    ...
    def GafferScene::Foo (self, *args, **kwargs):
      '''None'''
    ...
    def GafferScene::FooDeformer (self, *args, **kwargs):
      '''None'''
    ...
    def GafferScene::RenderPassWedge (self, *args, **kwargs):
      '''None'''
    ...
    def GafferScene::ShaderBall (self, *args, **kwargs):
      '''None'''
    ...
    def GafferSceneUI::LightEditor::Settings (self, *args, **kwargs):
      '''None'''
    ...
    def GafferSceneUI::RenderPassEditor::Settings (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::AddNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::ArrayPlugNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::BadNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::CachingTestNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::CompoundNumericNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::CompoundPlugNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::FrameNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::KeywordPlugNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTest::StringInOutNode (self, *args, **kwargs):
      '''None'''
    ...
    def GafferTractor::TractorDispatcher (self, *args, **kwargs):
      '''None'''
    ...
    def GafferUI::Editor::Settings (self, *args, **kwargs):
      '''None'''
    ...
    def GafferUITest::MyView (self, *args, **kwargs):
      '''None'''
    ...
    def GafferUITest::TestTool (self, *args, **kwargs):
      '''None'''
    ...
    def HalfData (self, *args, **kwargs):
      '''None'''
    ...
    def HalfVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def IDXReader (self, *args, **kwargs):
      '''None'''
    ...
    def IndexedIO (self, *args, **kwargs):
      '''None'''
    ...
    def Int64Data (self, *args, **kwargs):
      '''None'''
    ...
    def Int64VectorData (self, *args, **kwargs):
      '''None'''
    ...
    def IntData (self, *args, **kwargs):
      '''None'''
    ...
    def IntParameter (self, *args, **kwargs):
      '''None'''
    ...
    def IntVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def IntVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def InternedStringData (self, *args, **kwargs):
      '''None'''
    ...
    def InternedStringVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def Invalid (self, *args, **kwargs):
      '''None'''
    ...
    def LayoutNode (self, *args, **kwargs):
      '''None'''
    ...
    def LensModel (self, *args, **kwargs):
      '''None'''
    ...
    def LineSegment3dData (self, *args, **kwargs):
      '''None'''
    ...
    def LineSegment3dParameter (self, *args, **kwargs):
      '''None'''
    ...
    def LineSegment3fData (self, *args, **kwargs):
      '''None'''
    ...
    def LineSegment3fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def LsHeaderOp (self, *args, **kwargs):
      '''None'''
    ...
    def M33dData (self, *args, **kwargs):
      '''None'''
    ...
    def M33dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def M33dVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def M33fData (self, *args, **kwargs):
      '''None'''
    ...
    def M33fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def M33fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def M44dData (self, *args, **kwargs):
      '''None'''
    ...
    def M44dParameter (self, *args, **kwargs):
      '''None'''
    ...
    def M44dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def M44dVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def M44fData (self, *args, **kwargs):
      '''None'''
    ...
    def M44fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def M44fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def M44fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def MatrixMultiplyOp (self, *args, **kwargs):
      '''None'''
    ...
    def MemoryIndexedIO (self, *args, **kwargs):
      '''None'''
    ...
    def ModifyOp (self, *args, **kwargs):
      '''None'''
    ...
    def NestedPlugTestNode (self, *args, **kwargs):
      '''None'''
    ...
    def NoComputeNode (self, *args, **kwargs):
      '''None'''
    ...
    def NodulePositionNode (self, *args, **kwargs):
      '''None'''
    ...
    def NullDispatcher (self, *args, **kwargs):
      '''None'''
    ...
    def NullObject (self, *args, **kwargs):
      '''None'''
    ...
    def Object (self, *args, **kwargs):
      '''None'''
    ...
    def ObjectParameter (self, *args, **kwargs):
      '''None'''
    ...
    def ObjectReader (self, *args, **kwargs):
      '''None'''
    ...
    def ObjectVector (self, *args, **kwargs):
      '''None'''
    ...
    def ObjectVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def ObjectWriter (self, *args, **kwargs):
      '''None'''
    ...
    def Op (self, *args, **kwargs):
      '''None'''
    ...
    def OptionalCompoundParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Parameter (self, *args, **kwargs):
      '''None'''
    ...
    def Parameterised (self, *args, **kwargs):
      '''None'''
    ...
    def PassThrough (self, *args, **kwargs):
      '''None'''
    ...
    def PathMatcherData (self, *args, **kwargs):
      '''None'''
    ...
    def PathParameter (self, *args, **kwargs):
      '''None'''
    ...
    def PathVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def Preset (self, *args, **kwargs):
      '''None'''
    ...
    def QuatdData (self, *args, **kwargs):
      '''None'''
    ...
    def QuatdVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def QuatdVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def QuatfData (self, *args, **kwargs):
      '''None'''
    ...
    def QuatfVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def QuatfVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def RandomRotationOp (self, *args, **kwargs):
      '''None'''
    ...
    def Reader (self, *args, **kwargs):
      '''None'''
    ...
    def RemovePrimitiveVariables (self, *args, **kwargs):
      '''None'''
    ...
    def RenamePrimitiveVariables (self, *args, **kwargs):
      '''None'''
    ...
    def ReorderedFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def ReversedFrameList (self, *args, **kwargs):
      '''None'''
    ...
    def RunTimeTyped (self, *args, **kwargs):
      '''None'''
    ...
    def SWAReader (self, *args, **kwargs):
      '''None'''
    ...
    def SearchReplaceOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceCatOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceConvertOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceCpOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceLsOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceMergeOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceMvOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceRenumberOp (self, *args, **kwargs):
      '''None'''
    ...
    def SequenceRmOp (self, *args, **kwargs):
      '''None'''
    ...
    def SerialisationTestNode (self, *args, **kwargs):
      '''None'''
    ...
    def ShortData (self, *args, **kwargs):
      '''None'''
    ...
    def ShortVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def SplineddData (self, *args, **kwargs):
      '''None'''
    ...
    def SplineddParameter (self, *args, **kwargs):
      '''None'''
    ...
    def SplinefColor3fData (self, *args, **kwargs):
      '''None'''
    ...
    def SplinefColor3fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def SplinefColor4fData (self, *args, **kwargs):
      '''None'''
    ...
    def SplinefColor4fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def SplineffData (self, *args, **kwargs):
      '''None'''
    ...
    def SplineffParameter (self, *args, **kwargs):
      '''None'''
    ...
    def StandardRadialLensModel (self, *args, **kwargs):
      '''None'''
    ...
    def StreamIndexedIO (self, *args, **kwargs):
      '''None'''
    ...
    def StringData (self, *args, **kwargs):
      '''None'''
    ...
    def StringParameter (self, *args, **kwargs):
      '''None'''
    ...
    def StringVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def StringVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def TestDispatcher (self, *args, **kwargs):
      '''None'''
    ...
    def ThrowingNode (self, *args, **kwargs):
      '''None'''
    ...
    def TimeCodeData (self, *args, **kwargs):
      '''None'''
    ...
    def TimeCodeParameter (self, *args, **kwargs):
      '''None'''
    ...
    def TimeDurationData (self, *args, **kwargs):
      '''None'''
    ...
    def TimeDurationParameter (self, *args, **kwargs):
      '''None'''
    ...
    def TimePeriodData (self, *args, **kwargs):
      '''None'''
    ...
    def TimePeriodParameter (self, *args, **kwargs):
      '''None'''
    ...
    def ToCoreConverter (self, *args, **kwargs):
      '''None'''
    ...
    def TransformationMatrixdData (self, *args, **kwargs):
      '''None'''
    ...
    def TransformationMatrixdParameter (self, *args, **kwargs):
      '''None'''
    ...
    def TransformationMatrixfData (self, *args, **kwargs):
      '''None'''
    ...
    def TransformationMatrixfParameter (self, *args, **kwargs):
      '''None'''
    ...
    def TypedObjectPlugNode (self, *args, **kwargs):
      '''None'''
    ...
    def UCharData (self, *args, **kwargs):
      '''None'''
    ...
    def UCharVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64Data (self, *args, **kwargs):
      '''None'''
    ...
    def UInt64VectorData (self, *args, **kwargs):
      '''None'''
    ...
    def UIntData (self, *args, **kwargs):
      '''None'''
    ...
    def UIntVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def UShortData (self, *args, **kwargs):
      '''None'''
    ...
    def UShortVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V2dData (self, *args, **kwargs):
      '''None'''
    ...
    def V2dDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V2dParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V2dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V2dVectorDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V2dVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V2fData (self, *args, **kwargs):
      '''None'''
    ...
    def V2fDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V2fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V2fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V2fVectorDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V2fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V2iData (self, *args, **kwargs):
      '''None'''
    ...
    def V2iDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V2iParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V2iVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V2iVectorDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V2iVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V3dData (self, *args, **kwargs):
      '''None'''
    ...
    def V3dDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V3dParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V3dVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V3dVectorDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V3dVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V3fData (self, *args, **kwargs):
      '''None'''
    ...
    def V3fDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V3fParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V3fVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V3fVectorDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V3fVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V3iData (self, *args, **kwargs):
      '''None'''
    ...
    def V3iDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V3iParameter (self, *args, **kwargs):
      '''None'''
    ...
    def V3iVectorData (self, *args, **kwargs):
      '''None'''
    ...
    def V3iVectorDataBase (self, *args, **kwargs):
      '''None'''
    ...
    def V3iVectorParameter (self, *args, **kwargs):
      '''None'''
    ...
    def ValidatedStringParameter (self, *args, **kwargs):
      '''None'''
    ...
    def VectorDataFilterOp (self, *args, **kwargs):
      '''None'''
    ...
    def Writer (self, *args, **kwargs):
      '''None'''
    ...
    def _Camera (self, *args, **kwargs):
      '''None'''
    ...
    def _ObjectPreview (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def gui (self, *args, **kwargs):
      '''None'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

def UCharData (*args):
      '''
__init__(boost::python::api::object, unsigned char)
__init__(_object*)

'''      
    ...

class UCharData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UCharData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned char> {lvalue},IECore::TypeId)

isInstanceOf( (UCharData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned char> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UCharData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<unsigned char> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UCharData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<unsigned char> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def UCharVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class UCharVectorData:
    def append (self, *args, **kwargs):
      '''
append( (UCharVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (UCharVectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},unsigned char)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (UCharVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (UCharVectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},unsigned char,long,long)

index( (UCharVectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},unsigned char)

index( (UCharVectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},unsigned char,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (UCharVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UCharVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},IECore::TypeId)

isInstanceOf( (UCharVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (UCharVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},unsigned long)

resize( (UCharVectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue},unsigned long,unsigned char)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (UCharVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (UCharVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UCharVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UCharVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<unsigned char, std::allocator<unsigned char> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def UInt64Data (*args):
      '''
__init__(boost::python::api::object, unsigned long)
__init__(_object*)

'''      
    ...

class UInt64Data:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UInt64Data)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned long> {lvalue},IECore::TypeId)

isInstanceOf( (UInt64Data)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned long> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UInt64Data)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<unsigned long> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UInt64Data)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<unsigned long> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def UInt64VectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class UInt64VectorData:
    def append (self, *args, **kwargs):
      '''
append( (UInt64VectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (UInt64VectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},unsigned long)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (UInt64VectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (UInt64VectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},unsigned long,long,long)

index( (UInt64VectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},unsigned long)

index( (UInt64VectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},unsigned long,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (UInt64VectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UInt64VectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},IECore::TypeId)

isInstanceOf( (UInt64VectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (UInt64VectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},unsigned long)

resize( (UInt64VectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue},unsigned long,unsigned long)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (UInt64VectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (UInt64VectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UInt64VectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UInt64VectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<unsigned long, std::allocator<unsigned long> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def UIntData (*args):
      '''
__init__(boost::python::api::object, unsigned int)
__init__(_object*)

'''      
    ...

class UIntData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UIntData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned int> {lvalue},IECore::TypeId)

isInstanceOf( (UIntData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned int> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UIntData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<unsigned int> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UIntData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<unsigned int> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def UIntVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class UIntVectorData:
    def append (self, *args, **kwargs):
      '''
append( (UIntVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (UIntVectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},unsigned int)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (UIntVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (UIntVectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},unsigned int,long,long)

index( (UIntVectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},unsigned int)

index( (UIntVectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},unsigned int,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (UIntVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UIntVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},IECore::TypeId)

isInstanceOf( (UIntVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (UIntVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},unsigned long)

resize( (UIntVectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue},unsigned long,unsigned int)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (UIntVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (UIntVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UIntVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UIntVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<unsigned int, std::allocator<unsigned int> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def UShortData (*args):
      '''
__init__(boost::python::api::object, unsigned short)
__init__(_object*)

'''      
    ...

class UShortData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UShortData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned short> {lvalue},IECore::TypeId)

isInstanceOf( (UShortData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<unsigned short> {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def maxValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def minValue (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UShortData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<unsigned short> {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UShortData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<unsigned short> {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def UShortVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class UShortVectorData:
    def append (self, *args, **kwargs):
      '''
append( (UShortVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (UShortVectorData)arg1, (int)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},unsigned short)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (UShortVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (UShortVectorData)arg1, (int)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},unsigned short,long,long)

index( (UShortVectorData)arg1, (int)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},unsigned short)

index( (UShortVectorData)arg1, (int)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},unsigned short,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (UShortVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (UShortVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},IECore::TypeId)

isInstanceOf( (UShortVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (UShortVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},unsigned long)

resize( (UShortVectorData)arg1, (int)arg2, (int)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue},unsigned long,unsigned short)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (UShortVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (UShortVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (UShortVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (UShortVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<unsigned short, std::allocator<unsigned short> > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def Unknown (*args):
      '''

'''      
    ...

def V2dData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Vec2<double>, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, Imath_3_1::Vec2<double>)
__init__(_object*)

'''      
    ...

class V2dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V2dData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec2<double> > {lvalue},IECore::TypeId)

isInstanceOf( (V2dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec2<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V2dData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec2<double> > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def V2dDataBase (*args):
      '''

'''      
    ...

class V2dDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2dDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec2<double> > {lvalue},IECore::TypeId)

isInstanceOf( (V2dDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec2<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2dDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2dDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2dParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V2dParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V2dParameter)arg1) -> V2d :

    C++ signature :
        Imath_3_1::Vec2<double> getTypedValue(IECore::TypedParameter<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2dParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec2<double> > {lvalue},IECore::TypeId)

isInstanceOf( (V2dParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec2<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V2dParameter)arg1, (V2d)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Vec2<double> > {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2dParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2dParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Vec2<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V2dParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Vec2<double> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V2dTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > >)

'''      
    ...

class V2dTree:
    def enclosedPoints (self, *args, **kwargs):
      '''
enclosedPoints( (V2dTree)arg1, (Box2d)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > enclosedPoints(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<double> const*, std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<double> >)'''
    ...
    def nearestNNeighbours (self, *args, **kwargs):
      '''
nearestNNeighbours( (V2dTree)arg1, (V2d)arg2, (int)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<double> const*, std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > > > {lvalue},Imath_3_1::Vec2<double>,unsigned int)'''
    ...
    def nearestNeighbour (self, *args, **kwargs):
      '''
nearestNeighbour( (V2dTree)arg1, (V2d)arg2) -> int :

    C++ signature :
        unsigned long nearestNeighbour(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<double> const*, std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > > > {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def nearestNeighbours (self, *args, **kwargs):
      '''
nearestNeighbours( (V2dTree)arg1, (V2d)arg2, (float)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<double> const*, std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > > > {lvalue},Imath_3_1::Vec2<double>,double)'''
    ...

def V2dVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class V2dVectorData:
    def append (self, *args, **kwargs):
      '''
append( (V2dVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (V2dVectorData)arg1, (V2d)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},Imath_3_1::Vec2<double>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (V2dVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V2dVectorData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (V2dVectorData)arg1, (V2d)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},Imath_3_1::Vec2<double>,long,long)

index( (V2dVectorData)arg1, (V2d)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},Imath_3_1::Vec2<double>)

index( (V2dVectorData)arg1, (V2d)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},Imath_3_1::Vec2<double>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (V2dVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2dVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2dVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (V2dVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},unsigned long)

resize( (V2dVectorData)arg1, (int)arg2, (V2d)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},unsigned long,Imath_3_1::Vec2<double>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V2dVectorData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (V2dVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (V2dVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2dVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2dVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2dVectorDataBase (*args):
      '''

'''      
    ...

class V2dVectorDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2dVectorDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2dVectorDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2dVectorDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2dVectorDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2dVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V2dVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V2dVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2dVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2dVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V2dVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue},std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2dVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2dVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V2dVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<double>, std::allocator<Imath_3_1::Vec2<double> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V2fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Vec2<float>, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, Imath_3_1::Vec2<float>)
__init__(_object*)

'''      
    ...

class V2fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V2fData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec2<float> > {lvalue},IECore::TypeId)

isInstanceOf( (V2fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec2<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V2fData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec2<float> > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def V2fDataBase (*args):
      '''

'''      
    ...

class V2fDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2fDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec2<float> > {lvalue},IECore::TypeId)

isInstanceOf( (V2fDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec2<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2fDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2fDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V2fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V2fParameter)arg1) -> V2f :

    C++ signature :
        Imath_3_1::Vec2<float> getTypedValue(IECore::TypedParameter<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec2<float> > {lvalue},IECore::TypeId)

isInstanceOf( (V2fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec2<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V2fParameter)arg1, (V2f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Vec2<float> > {lvalue},Imath_3_1::Vec2<float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Vec2<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V2fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Vec2<float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V2fTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > >)

'''      
    ...

class V2fTree:
    def enclosedPoints (self, *args, **kwargs):
      '''
enclosedPoints( (V2fTree)arg1, (Box2f)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > enclosedPoints(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<float> const*, std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec2<float> >)'''
    ...
    def nearestNNeighbours (self, *args, **kwargs):
      '''
nearestNNeighbours( (V2fTree)arg1, (V2f)arg2, (int)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<float> const*, std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > > > {lvalue},Imath_3_1::Vec2<float>,unsigned int)'''
    ...
    def nearestNeighbour (self, *args, **kwargs):
      '''
nearestNeighbour( (V2fTree)arg1, (V2f)arg2) -> int :

    C++ signature :
        unsigned long nearestNeighbour(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<float> const*, std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > > > {lvalue},Imath_3_1::Vec2<float>)'''
    ...
    def nearestNeighbours (self, *args, **kwargs):
      '''
nearestNeighbours( (V2fTree)arg1, (V2f)arg2, (float)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec2<float> const*, std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > > > {lvalue},Imath_3_1::Vec2<float>,float)'''
    ...

def V2fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class V2fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (V2fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (V2fVectorData)arg1, (V2f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},Imath_3_1::Vec2<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (V2fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V2fVectorData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (V2fVectorData)arg1, (V2f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},Imath_3_1::Vec2<float>,long,long)

index( (V2fVectorData)arg1, (V2f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},Imath_3_1::Vec2<float>)

index( (V2fVectorData)arg1, (V2f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},Imath_3_1::Vec2<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (V2fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (V2fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},unsigned long)

resize( (V2fVectorData)arg1, (int)arg2, (V2f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},unsigned long,Imath_3_1::Vec2<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V2fVectorData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (V2fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (V2fVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2fVectorDataBase (*args):
      '''

'''      
    ...

class V2fVectorDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2fVectorDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2fVectorDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2fVectorDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2fVectorDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V2fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V2fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V2fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue},std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V2fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Vec2<float>, std::allocator<Imath_3_1::Vec2<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V2iData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Vec2<int>, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, Imath_3_1::Vec2<int>)
__init__(_object*)

'''      
    ...

class V2iData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V2iData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2iData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec2<int> > {lvalue},IECore::TypeId)

isInstanceOf( (V2iData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec2<int> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V2iData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec2<int> > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2iData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2iData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def V2iDataBase (*args):
      '''

'''      
    ...

class V2iDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2iDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec2<int> > {lvalue},IECore::TypeId)

isInstanceOf( (V2iDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec2<int> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2iDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2iDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2iParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V2iParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V2iParameter)arg1) -> V2i :

    C++ signature :
        Imath_3_1::Vec2<int> getTypedValue(IECore::TypedParameter<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2iParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec2<int> > {lvalue},IECore::TypeId)

isInstanceOf( (V2iParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec2<int> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V2iParameter)arg1, (V2i)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Vec2<int> > {lvalue},Imath_3_1::Vec2<int>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2iParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2iParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Vec2<int> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V2iParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Vec2<int> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V2iVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class V2iVectorData:
    def append (self, *args, **kwargs):
      '''
append( (V2iVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (V2iVectorData)arg1, (V2i)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},Imath_3_1::Vec2<int>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (V2iVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V2iVectorData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (V2iVectorData)arg1, (V2i)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},Imath_3_1::Vec2<int>,long,long)

index( (V2iVectorData)arg1, (V2i)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},Imath_3_1::Vec2<int>)

index( (V2iVectorData)arg1, (V2i)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},Imath_3_1::Vec2<int>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (V2iVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2iVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2iVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (V2iVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},unsigned long)

resize( (V2iVectorData)arg1, (int)arg2, (V2i)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},unsigned long,Imath_3_1::Vec2<int>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V2iVectorData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (V2iVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (V2iVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2iVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2iVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V2iVectorDataBase (*args):
      '''

'''      
    ...

class V2iVectorDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V2iVectorDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V2iVectorDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V2iVectorDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V2iVectorDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Vec2<int>, std::allocator<Imath_3_1::Vec2<int> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3dData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Vec3<double>, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, Imath_3_1::Vec3<double>)
__init__(_object*)

'''      
    ...

class V3dData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V3dData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3dData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec3<double> > {lvalue},IECore::TypeId)

isInstanceOf( (V3dData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec3<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V3dData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec3<double> > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3dData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3dData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def V3dDataBase (*args):
      '''

'''      
    ...

class V3dDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3dDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec3<double> > {lvalue},IECore::TypeId)

isInstanceOf( (V3dDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec3<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3dDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3dDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3dParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V3dParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V3dParameter)arg1) -> V3d :

    C++ signature :
        Imath_3_1::Vec3<double> getTypedValue(IECore::TypedParameter<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3dParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec3<double> > {lvalue},IECore::TypeId)

isInstanceOf( (V3dParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec3<double> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V3dParameter)arg1, (V3d)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Vec3<double> > {lvalue},Imath_3_1::Vec3<double>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3dParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3dParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Vec3<double> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V3dParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Vec3<double> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V3dTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > >)

'''      
    ...

class V3dTree:
    def enclosedPoints (self, *args, **kwargs):
      '''
enclosedPoints( (V3dTree)arg1, (Box3d)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > enclosedPoints(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<double> const*, std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<double> >)'''
    ...
    def nearestNNeighbours (self, *args, **kwargs):
      '''
nearestNNeighbours( (V3dTree)arg1, (V3d)arg2, (int)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<double> const*, std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > > > {lvalue},Imath_3_1::Vec3<double>,unsigned int)'''
    ...
    def nearestNeighbour (self, *args, **kwargs):
      '''
nearestNeighbour( (V3dTree)arg1, (V3d)arg2) -> int :

    C++ signature :
        unsigned long nearestNeighbour(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<double> const*, std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > > > {lvalue},Imath_3_1::Vec3<double>)'''
    ...
    def nearestNeighbours (self, *args, **kwargs):
      '''
nearestNeighbours( (V3dTree)arg1, (V3d)arg2, (float)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<double> const*, std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > > > {lvalue},Imath_3_1::Vec3<double>,double)'''
    ...

def V3dVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class V3dVectorData:
    def append (self, *args, **kwargs):
      '''
append( (V3dVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (V3dVectorData)arg1, (V3d)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},Imath_3_1::Vec3<double>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (V3dVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V3dVectorData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (V3dVectorData)arg1, (V3d)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},Imath_3_1::Vec3<double>,long,long)

index( (V3dVectorData)arg1, (V3d)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},Imath_3_1::Vec3<double>)

index( (V3dVectorData)arg1, (V3d)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},Imath_3_1::Vec3<double>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (V3dVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3dVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3dVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (V3dVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},unsigned long)

resize( (V3dVectorData)arg1, (int)arg2, (V3d)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},unsigned long,Imath_3_1::Vec3<double>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V3dVectorData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (V3dVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (V3dVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3dVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3dVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3dVectorDataBase (*args):
      '''

'''      
    ...

class V3dVectorDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3dVectorDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3dVectorDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3dVectorDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3dVectorDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3dVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V3dVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V3dVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3dVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3dVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V3dVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue},std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3dVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3dVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V3dVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<double>, std::allocator<Imath_3_1::Vec3<double> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V3fData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Vec3<float>, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, Imath_3_1::Vec3<float>)
__init__(_object*)

'''      
    ...

class V3fData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V3fData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3fData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec3<float> > {lvalue},IECore::TypeId)

isInstanceOf( (V3fData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec3<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V3fData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec3<float> > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3fData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3fData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def V3fDataBase (*args):
      '''

'''      
    ...

class V3fDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3fDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec3<float> > {lvalue},IECore::TypeId)

isInstanceOf( (V3fDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec3<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3fDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3fDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3fParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V3fParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V3fParameter)arg1) -> V3f :

    C++ signature :
        Imath_3_1::Vec3<float> getTypedValue(IECore::TypedParameter<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3fParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec3<float> > {lvalue},IECore::TypeId)

isInstanceOf( (V3fParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec3<float> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V3fParameter)arg1, (V3f)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Vec3<float> > {lvalue},Imath_3_1::Vec3<float>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3fParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3fParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Vec3<float> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V3fParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Vec3<float> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V3fTree (*args):
      '''
__init__(_object*, boost::intrusive_ptr<IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > >)

'''      
    ...

class V3fTree:
    def enclosedPoints (self, *args, **kwargs):
      '''
enclosedPoints( (V3fTree)arg1, (Box3f)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > enclosedPoints(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<float> const*, std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > > > {lvalue},Imath_3_1::Box<Imath_3_1::Vec3<float> >)'''
    ...
    def nearestNNeighbours (self, *args, **kwargs):
      '''
nearestNNeighbours( (V3fTree)arg1, (V3f)arg2, (int)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<float> const*, std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > > > {lvalue},Imath_3_1::Vec3<float>,unsigned int)'''
    ...
    def nearestNeighbour (self, *args, **kwargs):
      '''
nearestNeighbour( (V3fTree)arg1, (V3f)arg2) -> int :

    C++ signature :
        unsigned long nearestNeighbour(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<float> const*, std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > > > {lvalue},Imath_3_1::Vec3<float>)'''
    ...
    def nearestNeighbours (self, *args, **kwargs):
      '''
nearestNeighbours( (V3fTree)arg1, (V3f)arg2, (float)arg3) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::TypedData<std::vector<int, std::allocator<int> > > > nearestNeighbours(IECorePython::KDTreeWrapper<IECore::KDTree<__gnu_cxx::__normal_iterator<Imath_3_1::Vec3<float> const*, std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > > > {lvalue},Imath_3_1::Vec3<float>,float)'''
    ...

def V3fVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class V3fVectorData:
    def append (self, *args, **kwargs):
      '''
append( (V3fVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (V3fVectorData)arg1, (V3f)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},Imath_3_1::Vec3<float>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (V3fVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V3fVectorData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (V3fVectorData)arg1, (V3f)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},Imath_3_1::Vec3<float>,long,long)

index( (V3fVectorData)arg1, (V3f)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},Imath_3_1::Vec3<float>)

index( (V3fVectorData)arg1, (V3f)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},Imath_3_1::Vec3<float>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (V3fVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3fVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3fVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (V3fVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},unsigned long)

resize( (V3fVectorData)arg1, (int)arg2, (V3f)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},unsigned long,Imath_3_1::Vec3<float>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V3fVectorData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (V3fVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (V3fVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3fVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3fVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3fVectorDataBase (*args):
      '''

'''      
    ...

class V3fVectorDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3fVectorDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3fVectorDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3fVectorDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3fVectorDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3fVectorParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V3fVectorParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V3fVectorParameter)arg1) -> object :

    C++ signature :
        std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > getTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3fVectorParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3fVectorParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V3fVectorParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue},std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3fVectorParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3fVectorParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V3fVectorParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<std::vector<Imath_3_1::Vec3<float>, std::allocator<Imath_3_1::Vec3<float> > > >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V3iData (*args):
      '''
__init__(boost::python::api::object, Imath_3_1::Vec3<int>, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, Imath_3_1::Vec3<int>)
__init__(_object*)

'''      
    ...

class V3iData:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V3iData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3iData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec3<int> > {lvalue},IECore::TypeId)

isInstanceOf( (V3iData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<Imath_3_1::Vec3<int> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V3iData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<Imath_3_1::Vec3<int> > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3iData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3iData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def value (self, *args, **kwargs):
      '''The value contained by the object.'''
    ...

def V3iDataBase (*args):
      '''

'''      
    ...

class V3iDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3iDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec3<int> > {lvalue},IECore::TypeId)

isInstanceOf( (V3iDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<Imath_3_1::Vec3<int> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3iDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3iDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3iParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=())
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False)
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, boost::python::api::object defaultValue, boost::python::api::object presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class V3iParameter:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (V3iParameter)arg1) -> V3i :

    C++ signature :
        Imath_3_1::Vec3<int> getTypedValue(IECore::TypedParameter<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3iParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec3<int> > {lvalue},IECore::TypeId)

isInstanceOf( (V3iParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedParameter<Imath_3_1::Vec3<int> > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (V3iParameter)arg1, (V3i)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<Imath_3_1::Vec3<int> > {lvalue},Imath_3_1::Vec3<int>)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3iParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedParameter<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3iParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedParameter<Imath_3_1::Vec3<int> > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (V3iParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::TypedParameter<Imath_3_1::Vec3<int> >,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def V3iVectorData (*args):
      '''
__init__(boost::python::api::object, boost::python::api::object, IECore::GeometricData::Interpretation)
__init__(boost::python::api::object, boost::python::api::object)
__init__(boost::python::api::object)

'''      
    ...

class V3iVectorData:
    def append (self, *args, **kwargs):
      '''
append( (V3iVectorData)arg1, (object)arg2) -> None :
    s.append(x)
    Appends a new element x to the end of s

    C++ signature :
        void append(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},_object*)'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def count (self, *args, **kwargs):
      '''
count( (V3iVectorData)arg1, (V3i)arg2) -> int :
    s.count(x)
    Count ocurrences of an element x in s

    C++ signature :
        unsigned long count(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},Imath_3_1::Vec3<int>)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (V3iVectorData)arg1, (object)arg2) -> None :
    s.extend(t)
    Appends a new vector or list t to the end of s

    C++ signature :
        void extend(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},boost::python::api::object)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getInterpretation (self, *args, **kwargs):
      '''
getInterpretation( (V3iVectorData)arg1) -> Interpretation :
    Returns the geometric interpretation of this data.

    C++ signature :
        IECore::GeometricData::Interpretation getInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def hasBase (self, *args, **kwargs):
      '''
hasBase() -> bool :

    C++ signature :
        bool hasBase()'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def index (self, *args, **kwargs):
      '''
index( (V3iVectorData)arg1, (V3i)arg2, (int)arg3, (int)arg4) -> int :
    s.index(x [,start [,stop]])
    Returns the smallest i where s[i] == x.
    start and stop optionally specify the starting and ending index for the search.

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},Imath_3_1::Vec3<int>,long,long)

index( (V3iVectorData)arg1, (V3i)arg2) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},Imath_3_1::Vec3<int>)

index( (V3iVectorData)arg1, (V3i)arg2, (int)arg3) -> int :

    C++ signature :
        unsigned long index(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},Imath_3_1::Vec3<int>,long)'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def insert (self, *args, **kwargs):
      '''
insert( (V3iVectorData)arg1, (object)arg2, (object)arg3) -> None :
    s.insert(i, x)
    Inserts x at index i.

    C++ signature :
        void insert(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},_object*,_object*)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3iVectorData)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3iVectorData)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def resize (self, *args, **kwargs):
      '''
resize( (V3iVectorData)arg1, (int)arg2) -> None :
    s.resize( size )
    Adjusts the size of s.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},unsigned long)

resize( (V3iVectorData)arg1, (int)arg2, (V3i)arg3) -> None :
    s.resize( size, value )
    Adjusts the size of s, inserting elements of value as necessary.

    C++ signature :
        void resize(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},unsigned long,Imath_3_1::Vec3<int>)'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def setInterpretation (self, *args, **kwargs):
      '''
setInterpretation( (V3iVectorData)arg1, (Interpretation)arg2) -> None :
    Sets the geometric interpretation of this data.

    C++ signature :
        void setInterpretation(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},IECore::GeometricData::Interpretation)'''
    ...
    def size (self, *args, **kwargs):
      '''
size( (V3iVectorData)arg1) -> int :
    s.size()
    Returns the number of elements on s. Same result as the len operator.

    C++ signature :
        unsigned long size(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (V3iVectorData)arg1) -> object :
    Returns a string with a copy of the bytes in the vector.

    C++ signature :
        boost::python::api::object toString(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3iVectorData)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3iVectorData)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::GeometricTypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def V3iVectorDataBase (*args):
      '''

'''      
    ...

class V3iVectorDataBase:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> copy(IECore::Object {lvalue})'''
    ...
    def copyFrom (self, *args, **kwargs):
      '''
copyFrom( (Object)arg1, (Object)arg2) -> None :

    C++ signature :
        void copyFrom(IECore::Object {lvalue},IECore::Object const*)'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (TypeId)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> create(IECore::TypeId)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def hash (self, *args, **kwargs):
      '''
hash( (Object)arg1) -> MurmurHash :

    C++ signature :
        IECore::MurmurHash hash(IECore::Object {lvalue})

hash( (Object)arg1, (MurmurHash)arg2) -> None :

    C++ signature :
        void hash(IECore::Object {lvalue},IECore::MurmurHash {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isAbstractType (self, *args, **kwargs):
      '''
isAbstractType( (object)arg1) -> bool :

    C++ signature :
        bool isAbstractType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isAbstractType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isAbstractType(IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (V3iVectorDataBase)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},IECore::TypeId)

isInstanceOf( (V3iVectorDataBase)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::TypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def isType (self, *args, **kwargs):
      '''
isType( (object)arg1) -> bool :

    C++ signature :
        bool isType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

isType( (TypeId)arg1) -> bool :

    C++ signature :
        bool isType(IECore::TypeId)'''
    ...
    def load (self, *args, **kwargs):
      '''
load( (object)ioInterface, (InternedString)name [, (Canceller)canceller=None]) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> load(boost::intrusive_ptr<IECore::IndexedIO const>,IECore::InternedString [,IECore::Canceller const*=None])'''
    ...
    def memoryUsage (self, *args, **kwargs):
      '''
memoryUsage( (Object)arg1) -> int :
    Returns the number of bytes this instance occupies in memory

    C++ signature :
        unsigned long memoryUsage(IECore::Object {lvalue})'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)typeId, (object)typeName [, (object)creator=None]) -> None :

    C++ signature :
        void registerType(IECore::TypeId,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,boost::python::api::object=None])'''
    ...
    def save (self, *args, **kwargs):
      '''
save( (Object)arg1, (object)arg2, (InternedString)arg3) -> None :

    C++ signature :
        void save(IECore::Object {lvalue},boost::intrusive_ptr<IECore::IndexedIO>,IECore::InternedString)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (V3iVectorDataBase)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::TypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (V3iVectorDataBase)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::TypedData<std::vector<Imath_3_1::Vec3<int>, std::allocator<Imath_3_1::Vec3<int> > > > {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...

def ValidatedStringParameter (*args):
      '''
__init__(_object*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > name, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > description, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > regex, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > regexDescription='', std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > defaultValue='', bool allowEmptyString=True, boost::python::api::object {lvalue} presets=(), bool presetsOnly=False, boost::intrusive_ptr<IECore::CompoundObject> userData=None)

'''      
    ...

class ValidatedStringParameter:
    def allowEmptyString (self, *args, **kwargs):
      '''None'''
    ...
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def defaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def getCurrentPresetName (self, *args, **kwargs):
      '''
getCurrentPresetName( (Parameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getCurrentPresetName(IECore::Parameter {lvalue})'''
    ...
    def getPresets (self, *args, **kwargs):
      '''
getPresets( (Parameter)arg1) -> dict :
    Returns a dictionary containing presets for the parameter.

    C++ signature :
        boost::python::dict getPresets(IECore::Parameter {lvalue})'''
    ...
    def getTypedValue (self, *args, **kwargs):
      '''
getTypedValue( (StringParameter)arg1) -> str :

    C++ signature :
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > getTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue})'''
    ...
    def getValidatedValue (self, *args, **kwargs):
      '''
getValidatedValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValidatedValue(IECore::Parameter {lvalue})'''
    ...
    def getValue (self, *args, **kwargs):
      '''
getValue( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> getValue(IECore::Parameter {lvalue})'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (ValidatedStringParameter)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ValidatedStringParameter {lvalue},IECore::TypeId)

isInstanceOf( (ValidatedStringParameter)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::ValidatedStringParameter {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def presetNames (self, *args, **kwargs):
      '''
presetNames( (Parameter)arg1) -> tuple :
    Returns a tuple containing the names of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetNames(IECore::Parameter)'''
    ...
    def presetValues (self, *args, **kwargs):
      '''
presetValues( (Parameter)arg1) -> tuple :
    Returns a tuple containing the values of all presets for the parameter.

    C++ signature :
        boost::python::tuple presetValues(IECore::Parameter)'''
    ...
    def presetsOnly (self, *args, **kwargs):
      '''None'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def regex (self, *args, **kwargs):
      '''None'''
    ...
    def regexDescription (self, *args, **kwargs):
      '''None'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def setPresets (self, *args, **kwargs):
      '''
setPresets( (Parameter)arg1, (object)arg2) -> None :
    Sets the presets for the parameter from a dictionary.

    C++ signature :
        void setPresets(IECore::Parameter {lvalue},boost::python::api::object)'''
    ...
    def setTypedValue (self, *args, **kwargs):
      '''
setTypedValue( (StringParameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setTypedValue(IECore::TypedParameter<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def setValidatedValue (self, *args, **kwargs):
      '''
setValidatedValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValidatedValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def setValue (self, *args, **kwargs):
      '''
setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)

setValue( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void setValue(IECore::Parameter {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def smartSetValue (self, value):
      '''
	Smart setValue operator for Parameter objects. Uses introspection on the given value to define
	how the value will be assigned to the Parameter object.
	'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (ValidatedStringParameter)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::ValidatedStringParameter {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (ValidatedStringParameter)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::ValidatedStringParameter {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def typedDefaultValue (self, *args, **kwargs):
      '''None'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameter)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::CompoundObject> userData(IECore::Parameter {lvalue})'''
    ...
    def validate (self, *args, **kwargs):
      '''
validate( (Parameter)arg1) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue})

validate( (Parameter)arg1, (object)arg2) -> None :

    C++ signature :
        void validate(IECore::Parameter {lvalue},boost::intrusive_ptr<IECore::Object>)'''
    ...
    def valueValid (self, *args, **kwargs):
      '''
valueValid( (ValidatedStringParameter)arg1, (object)arg2) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::ValidatedStringParameter,boost::intrusive_ptr<IECore::Object const>)

valueValid( (Parameter)arg1) -> tuple :
    Returns a tuple containing a bool specifying validity and a string giving a reason for invalidity.

    C++ signature :
        boost::python::tuple valueValid(IECore::Parameter)'''
    ...

def VectorDataFilterOp (*args):
      '''
__init__(_object*)

'''      
    ...

class VectorDataFilterOp:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (VectorDataFilterOp)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::VectorDataFilterOp {lvalue},IECore::TypeId)

isInstanceOf( (VectorDataFilterOp)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::VectorDataFilterOp {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (VectorDataFilterOp)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::VectorDataFilterOp {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (VectorDataFilterOp)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::VectorDataFilterOp {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...

def Winding (*args):
      '''

'''      
    ...

class Winding:
    def Clockwise (self, *args, **kwargs):
      '''None'''
    ...
    def CounterClockwise (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

def WrappedTextFormatter (*args):
      '''

'''      
    ...

class WrappedTextFormatter:
    def _WrappedTextFormatter__blankLine (self):
      '''None'''
    ...
    def _WrappedTextFormatter__indent (self):
      '''None'''
    ...
    def _WrappedTextFormatter__output (self, text):
      '''None'''
    ...
    def heading (self, name):
      '''None'''
    ...
    def indent (self):
      '''None'''
    ...
    def paragraph (self, text):
      '''None'''
    ...
    def unindent (self):
      '''None'''
    ...

def Writer (*args):
      '''

'''      
    ...

class Writer:
    def baseTypeId (self, *args, **kwargs):
      '''
baseTypeId([  (TypeId)arg1]) -> TypeId :

    C++ signature :
        IECore::TypeId baseTypeId([ IECore::TypeId])'''
    ...
    def baseTypeIds (self, *args, **kwargs):
      '''
baseTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list baseTypeIds(IECore::TypeId)'''
    ...
    def baseTypeName (self, *args, **kwargs):
      '''
baseTypeName() -> str :

    C++ signature :
        char const* baseTypeName()'''
    ...
    def collectGarbage (self, *args, **kwargs):
      '''
collectGarbage() -> None :

    C++ signature :
        void collectGarbage()'''
    ...
    def create (self, *args, **kwargs):
      '''
create( (object)arg1, (object)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Writer> create(boost::intrusive_ptr<IECore::Object>,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)

create( (object)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Writer> create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'''
    ...
    def derivedTypeIds (self, *args, **kwargs):
      '''
derivedTypeIds( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list derivedTypeIds(IECore::TypeId)'''
    ...
    def description (self, *args, **kwargs):
      '''None'''
    ...
    def garbageCollectionThreshold (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def inheritsFrom (self, *args, **kwargs):
      '''
inheritsFrom( (str)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(char const*)

inheritsFrom( (TypeId)arg1) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId)

inheritsFrom( (str)arg1, (str)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(char const*,char const*)

inheritsFrom( (TypeId)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool inheritsFrom(IECore::TypeId,IECore::TypeId)'''
    ...
    def isInstanceOf (self, *args, **kwargs):
      '''
isInstanceOf( (Writer)arg1, (TypeId)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Writer {lvalue},IECore::TypeId)

isInstanceOf( (Writer)arg1, (str)arg2) -> bool :

    C++ signature :
        bool isInstanceOf(IECore::Writer {lvalue},char const*)'''
    ...
    def isSame (self, *args, **kwargs):
      '''
isSame( (RefCounted)arg1, (RefCounted)arg2) -> bool :

    C++ signature :
        bool isSame(IECore::RefCounted const*,IECore::RefCounted const*)'''
    ...
    def numWrappedInstances (self, *args, **kwargs):
      '''
numWrappedInstances() -> int :

    C++ signature :
        unsigned long numWrappedInstances()'''
    ...
    def operate (self, *args, **kwargs):
      '''
operate( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue})

operate( (Op)arg1, (CompoundObject)arg2) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Object> operate(IECore::Op {lvalue},IECore::CompoundObject const*)'''
    ...
    def parameters (self, *args, **kwargs):
      '''
parameters( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundParameter* parameters(IECore::Parameterised {lvalue})'''
    ...
    def refCount (self, *args, **kwargs):
      '''
refCount( (RefCounted)arg1) -> int :

    C++ signature :
        unsigned long refCount(IECore::RefCounted {lvalue})'''
    ...
    def registerType (self, *args, **kwargs):
      '''
registerType( (TypeId)arg1, (str)arg2, (TypeId)arg3) -> None :

    C++ signature :
        void registerType(IECore::TypeId,char const*,IECore::TypeId)'''
    ...
    def resultParameter (self, *args, **kwargs):
      '''
resultParameter( (Op)arg1) -> object :

    C++ signature :
        boost::intrusive_ptr<IECore::Parameter> resultParameter(IECore::Op)'''
    ...
    def staticTypeId (self, *args, **kwargs):
      '''
staticTypeId() -> TypeId :

    C++ signature :
        IECore::TypeId staticTypeId()'''
    ...
    def staticTypeName (self, *args, **kwargs):
      '''
staticTypeName() -> str :

    C++ signature :
        char const* staticTypeName()'''
    ...
    def supportedExtensions (self, *args, **kwargs):
      '''
supportedExtensions() -> list :

    C++ signature :
        boost::python::list supportedExtensions()

supportedExtensions( (TypeId)arg1) -> list :

    C++ signature :
        boost::python::list supportedExtensions(IECore::TypeId)'''
    ...
    def typeId (self, *args, **kwargs):
      '''
typeId( (Writer)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeId(IECore::Writer {lvalue})'''
    ...
    def typeIdFromTypeName (self, *args, **kwargs):
      '''
typeIdFromTypeName( (str)arg1) -> TypeId :

    C++ signature :
        IECore::TypeId typeIdFromTypeName(char const*)'''
    ...
    def typeName (self, *args, **kwargs):
      '''
typeName( (Writer)arg1) -> str :

    C++ signature :
        char const* typeName(IECore::Writer {lvalue})'''
    ...
    def typeNameFromTypeId (self, *args, **kwargs):
      '''
typeNameFromTypeId( (TypeId)arg1) -> str :

    C++ signature :
        char const* typeNameFromTypeId(IECore::TypeId)'''
    ...
    def userData (self, *args, **kwargs):
      '''
userData( (Parameterised)arg1) -> object :

    C++ signature :
        IECore::CompoundObject* userData(IECore::Parameterised {lvalue})'''
    ...
    def write (self, *args, **kwargs):
      '''
write( (Writer)arg1) -> None :

    C++ signature :
        void write(IECore::Writer {lvalue})'''
    ...

def _IECore (*args):
      '''

'''      
    ...

def __builtins__ (*args):
      '''

'''      
    ...

def __cached__ (*args):
      '''

'''      
    ...

def __doc__ (*args):
      '''

'''      
    ...

def __file__ (*args):
      '''

'''      
    ...

def __loader__ (*args):
      '''

'''      
    ...

def __name__ (*args):
      '''

'''      
    ...

def __package__ (*args):
      '''

'''      
    ...

def __path__ (*args):
      '''

'''      
    ...

def __spec__ (*args):
      '''

'''      
    ...

def address (*args):
      '''

'''      
    ...

def bezierSubdivide (*args):
      '''

'''      
    ...

def cat (*args):
      '''

'''      
    ...

def compatibilityVersion (*args):
      '''

'''      
    ...

def compatibilityVersionString (*args):
      '''

'''      
    ...

def cp (*args):
      '''

'''      
    ...

def curry (*args):
      '''

'''      
    ...

def dataFromElement (*args):
      '''

'''      
    ...

def dataTypeFromElement (*args):
      '''

'''      
    ...

def dataTypeFromElementType (*args):
      '''

'''      
    ...

def debug (*args):
      '''

'''      
    ...

def debugException (*args):
      '''

'''      
    ...

def decToHexChar (*args):
      '''

'''      
    ...

def decToHexCharVector (*args):
      '''

'''      
    ...

def decToHexUInt (*args):
      '''

'''      
    ...

def decToHexUIntVector (*args):
      '''

'''      
    ...

def degreesToRadians (*args):
      '''

'''      
    ...

def elementTypeFromDataType (*args):
      '''

'''      
    ...

def error (*args):
      '''

'''      
    ...

def exceptionInfo (*args):
      '''

'''      
    ...

def findSequences (*args):
      '''

'''      
    ...

def formatParameterHelp (*args):
      '''

'''      
    ...

def frameListFromList (*args):
      '''

'''      
    ...

def getDataDerivedTypes (*args):
      '''

'''      
    ...

def getGeometricInterpretation (*args):
      '''

'''      
    ...

def hardwareConcurrency (*args):
      '''

'''      
    ...

def henyeyGreenstein (*args):
      '''

'''      
    ...

def henyeyGreensteinCT (*args):
      '''

'''      
    ...

def hexToDecChar (*args):
      '''

'''      
    ...

def hexToDecCharVector (*args):
      '''

'''      
    ...

def hexToDecUInt (*args):
      '''

'''      
    ...

def hexToDecUIntVector (*args):
      '''

'''      
    ...

def info (*args):
      '''

'''      
    ...

def initThreads (*args):
      '''

'''      
    ...

def isDebug (*args):
      '''

'''      
    ...

def isMappingDataType (*args):
      '''

'''      
    ...

def isSequenceDataType (*args):
      '''

'''      
    ...

def isSimpleDataType (*args):
      '''

'''      
    ...

def isSimpleNumericDataType (*args):
      '''

'''      
    ...

def linearObjectInterpolation (*args):
      '''

'''      
    ...

def loadConfig (*args):
      '''

'''      
    ...

def ls (*args):
      '''

'''      
    ...

def majorVersion (*args):
      '''

'''      
    ...

def milestoneVersion (*args):
      '''

'''      
    ...

def minorVersion (*args):
      '''

'''      
    ...

def msg (*args):
      '''

'''      
    ...

def mv (*args):
      '''

'''      
    ...

def patchVersion (*args):
      '''

'''      
    ...

def polygonArea (*args):
      '''

'''      
    ...

def polygonBound (*args):
      '''

'''      
    ...

def polygonNormal (*args):
      '''

'''      
    ...

def polygonWinding (*args):
      '''

'''      
    ...

def radiansToDegrees (*args):
      '''

'''      
    ...

def registerObject (*args):
      '''

'''      
    ...

def registerRunTimeTyped (*args):
      '''

'''      
    ...

def repr (*args):
      '''

'''      
    ...

def rm (*args):
      '''

'''      
    ...

def setGeometricInterpretation (*args):
      '''

'''      
    ...

def setLogLevel (*args):
      '''

'''      
    ...

def setLogLevelByName (*args):
      '''

'''      
    ...

def showCallStack (*args):
      '''

'''      
    ...

def sign (*args):
      '''

'''      
    ...

def size (*args):
      '''

'''      
    ...

def tbb_global_control (*args):
      '''
__init__(_object*, tbb::interface9::global_control::parameter, unsigned long)

'''      
    ...

class tbb_global_control:
    def active_value (self, *args, **kwargs):
      '''
active_value( (parameter)arg1) -> int :

    C++ signature :
        unsigned long active_value(tbb::interface9::global_control::parameter)'''
    ...
    def parameter (self, *args, **kwargs):
      '''None'''
    ...

def tbb_task_scheduler_init (*args):
      '''
__init__(_object*, int max_threads=-1)

'''      
    ...

class tbb_task_scheduler_init:
    def automatic (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...

def testLRUCacheThreading (*args):
      '''

'''      
    ...

def testMurmurHashDispatch (*args):
      '''

'''      
    ...

def testParallelLRUCacheRecursion (*args):
      '''

'''      
    ...

def testPathMatcherFind (*args):
      '''

'''      
    ...

def testPathMatcherIteratorPrune (*args):
      '''

'''      
    ...

def testPathMatcherRawIterator (*args):
      '''

'''      
    ...

def testSerialLRUCacheRecursion (*args):
      '''

'''      
    ...

def triangleArea (*args):
      '''

'''      
    ...

def triangleContainsPoint (*args):
      '''

'''      
    ...

def triangleNormal (*args):
      '''

'''      
    ...

def trianglePoint (*args):
      '''

'''      
    ...

def uniqueValues (*args):
      '''

'''      
    ...

def valueTypeFromSequenceType (*args):
      '''

'''      
    ...

def versionString (*args):
      '''

'''      
    ...

def warning (*args):
      '''

'''      
    ...

def withFreeType (*args):
      '''

'''      
    ...
